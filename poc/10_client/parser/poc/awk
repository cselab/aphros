#!/bin/sh

${AWK=awk} '
BEGIN {
    SPACE = "^[\\t ]+"
    TOK = "^[_a-zA-Z][_0-9a-zA-Z]*"
    COMMANDS = "^(set)|(include)|(del)$"
    TYPES = "^(double)|(int)|(string)|(vect)$"
    INT = "^[+-]?[0-9][0-9]*$"
    DOUBLE = "^[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?$"
    STRING = ".*"
    parse(ARGV[1])
}

function parse(File) {
    while (getline < File > 0) {
        No++
        line = $0
        gsub(/#.*/, "")
        if (/^[\t ]*$/) continue
        nxt(SPACE)
        if (!nxt(TOK))
            err("expecting command")
        Command = Match
        if (Command !~ COMMANDS)
            err("unexpected command \"%s\"", Match)
        if (eq(Command, "set")) {
            if (!nxt(SPACE))
                err("no space after set")
            if (!nxt(TOK))
                err("expecting a type")
            Type = Match
            if (Type !~ TYPES)
                err("unknown type \"%s\"", Type)
            if (!nxt(SPACE))
                err("no space after type")
            if (!nxt(TOK))
                err("not a valid variable name")
            Key = Match
            nxt(SPACE)            
            if (eq(Type, "string")) {
                nxt(STRING)
                Value = Match
            } else if (eq(Type, "int")) {
                if (!nxt(INT))
                    err("not an integer")
                Value = Match
            } else if (eq(Type, "double")) {
                if (!nxt(DOUBLE))
                    err("not a double")
                Value = Match
            } else if (eq(Type, "vect")) {
                nxt(STRING)
                Value = Match
                n = split(Value, Vect)
                if (n == 0)
                    err("empty vector")
                for (i = 1; i <= n; i++) {
                    if (Vect[i] !~ DOUBLE)
                        err("not a double \"%s\"", Vect[i])
                    Vect[i] += 0
                }
            }
            if (!empty($0))
                err("unknown string at the end of set")
            if (!eq(Type, "vect"))
                msg("%s:%s:%s:%s", Command, Key, Type, Value)
            else {
                msg("%s:%s:%s[%d]:%g [..] %g",
                    Command, Key, Type, n, Vect[1], Vect[n])
            }
        } else if (Command == "del") {
            if (!nxt(SPACE))
                err("no space after set")
            if (!nxt(TOK))
                err("expecting a variable name")
            Key = Match
            nxt(SPACE)
            if (!empty($0))
                err("unknown string at the end of del")
            msg("%s:%s", Command, Key)
        } else if (Command == "include") {
            if (!nxt(SPACE))
                err("no space after include")
            nxt(STRING)
            Path = Match
            msg("file: %s", Path)
            filep(Path)
            parse(Path)
            # TODO
        } else {
            msg("unknown command: %s", Command)
        }
    }
}

function nxt(e) {
    if (!match($0, e))
        return 0
    Match = substr($0, RSTART, RLENGTH)
    $0 = substr($0, RSTART + RLENGTH)
    return 1
}

function err(f, a, b, c, d, e, g)
{
    msg(f, a, b, c, d, e, g)
    exit(2)
}

function msg(f, a, b, c, d, e, g)
{
    printf "%s:%d:", File, No | "cat >&2"
    printf " " f, a , b, c, d, e, g  | "cat >&2"
    printf "\n" | "cat >&2"
}

function empty(s)
{
    return length(s) == 0
}

function eq(a, b)
{
    return a "" == b ""
}

function filep(path,   c)
{
    c = sprintf("test -f %s", quote(path))
    msg(system(c))
}

function quote(s)
{
    return "'\''" s "'\''"
}

' "$@"
