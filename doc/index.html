<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <meta name="description" content="Aphros documentation. Finite volume solver for incompressible multiphase flows with surface tension. Foaming flows in complex geometries." />
    <meta http-equiv="content-language" content="en-us" />
    <title>Aphros documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
  </head>
  <body>
    
  <div class="section" id="aphros">
<h1>Aphros<a class="headerlink" href="#aphros" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-intro"></span><div class="section" id="introduction">
<h2><span class="section-number">1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><strong>Aphros</strong> is a finite volume solver for incompressible multiphase flows with
surface tension. Key features:</p>
<ul class="simple">
<li><p>implementation in C++14</p></li>
<li><p>abstractions for mesh elements (cells, faces and nodes),
range-based loops over them
and the corresponding data fields (cell-, face- and node-based fields)</p></li>
<li><p>convenient and fast development (no need to write 3D loops)
using only standard features of the language
(without code generators or domain-specific languages)</p></li>
<li><p>scalability to thousands of compute nodes using MPI/OpenMP
thanks to the Cubism library for distributed computing on structured grids</p></li>
<li><p>coroutines to enable encapsulation in the block-wise processing framework</p></li>
<li><p>individual solvers can be used separately as regular classes or functions</p></li>
<li><p>fluid solver based on SIMPLE or Bell-Colella-Glaz methods</p></li>
<li><p>conservative split advection solver based on PLIC</p></li>
<li><p>method of particles for curvature estimation that outperforms
standard techniques at low resolutions
which is well-suited for simulation with many small bubbles and drops</p></li>
<li><p>multilayer volume-of-fluid scheme for coalescence prevention
which has the computational cost that does not depend on the number
of bubbles in the simulation and therefore
can describe processes such as generation of foam</p></li>
</ul>
<p>The source code is available on <a class="reference external" href="https://github.com/cselab/aphros">GitHub</a>.</p>
</div>
<span id="document-comm"></span><div class="section" id="communication">
<span id="s-comm"></span><h2><span class="section-number">2. </span>Communication<a class="headerlink" href="#communication" title="Permalink to this headline">¶</a></h2>
<p>The grid is decomposed into subdomains, one for each MPI rank.
Each subdomain is further divided into cubic blocks of fixed size.
The program is built following the SPMD (single program multiple data) model.
Each MPI rank processes its blocks sequentially.
The code is divided into <em>stages</em>
which are executed in parallel on all blocks
with synchronization after every stage.
This implements <em>coroutines</em>.
The code can issue communication requests
which are collected during each stage
and executed before transferring to the next stage.</p>
<p>The following function consists of two stages:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="n">Mesh</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">sem</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">GetSem</span><span class="p">();</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fc</span><span class="p">;</span>
  <span class="p">}</span><span class="o">*</span> <span class="n">ctx</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fc</span><span class="p">.</span><span class="n">Reinit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">GetId</span><span class="p">());</span>
    <span class="n">m</span><span class="p">.</span><span class="n">Comm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fc</span><span class="p">.</span><span class="n">Reinit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mesh <cite>m</cite> provides functionality for parallel communication.
Pointer <cite>ctx</cite> will be initialized to point at an instance
of the user-defined <cite>struct</cite> persistent across stages
of one call of the function.
The instance is created before the execution of the first stage
and destroyed after the last stage.</p>
<p>Communication requests include:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">void</span> <span class="n">Comm</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CommRequest</span><span class="o">&gt;&amp;&amp;</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">void</span> <span class="n">Reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Op</span><span class="o">&gt;&amp;&amp;</span> <span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">void</span> <span class="n">GatherToLead</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">buf</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">void</span> <span class="n">Dump</span><span class="p">(</span><span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">field</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-convdiff"></span><div class="section" id="convection-diffusion-equation">
<span id="s-convdiff"></span><h2><span class="section-number">3. </span>Convection-diffusion equation<a class="headerlink" href="#convection-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>Abstract class <code class="docutils literal notranslate"><span class="pre">ConvDiffVect</span></code> describes the interface
of a solver for the vector convection-diffusion equation</p>
<div class="math">
<p><img src="_images/math/411eacddfb096a19ce9fcebf7e3b15fb1974bf92.svg" alt="\rho \Big(
\frac{\partial \mathbf{u}}{\partial t}
+ (\mathbf{v}\cdot\nabla) \mathbf{u}
\Big)
= \nabla \cdot (\mu \nabla \mathbf{u})
+ \mathbf{f}"/></p>
</div><p>in the discrete form</p>
<div class="math" id="equation-e-momentum">
<p><span class="eqno">(3.1)<a class="headerlink" href="#equation-e-momentum" title="Permalink to this equation">¶</a></span><img src="_images/math/0f93facf5b44568d71ef4da031d12521dda135e8.svg" alt="\rho_c \Big(
\frac{\delta \mathbf{u}_c}{\delta t}
+ \frac{1}{V_c}\sum_{f\in c} v_f \mathbf{u}_f S^c_{\!f}
\Big)
= \frac{1}{V_c}\sum_{f\in c} \mu_f
  \frac{\delta \mathbf{u}_f}{\delta n} S^c_{\!f}
+ \mathbf{f}_c"/></p>
</div><p>where <img class="math" src="_images/math/c638da8edb6ea1a653ade24e1409935eca6a1521.svg" alt="c" style="vertical-align: 0px"/> is a cell index,
<img class="math" src="_images/math/094bd97918d7c5d512e1cef3860853479e1ede35.svg" alt="\phi_c" style="vertical-align: -4px"/> is a cell-average,
<img class="math" src="_images/math/bea1295cdbb6955826a09b2733b95dacd4bcacee.svg" alt="f\in c" style="vertical-align: -4px"/> are neighbour faces of cell <img class="math" src="_images/math/c638da8edb6ea1a653ade24e1409935eca6a1521.svg" alt="c" style="vertical-align: 0px"/>,
<img class="math" src="_images/math/f8ca91f214fad6effa57d0d20e84c87cfd98193d.svg" alt="\phi_f" style="vertical-align: -6px"/> is a face-average,
<img class="math" src="_images/math/3fcf89a142bda32d674fd6dc581a9bc8a78019ca.svg" alt="S^c_{\!f}" style="vertical-align: -9px"/> is the signed face area
(positive if <img class="math" src="_images/math/64d4bdeef60a070469a0751f01649948f10230d8.svg" alt="\mathbf{n}_f" style="vertical-align: -6px"/> is an outer normal to <img class="math" src="_images/math/c638da8edb6ea1a653ade24e1409935eca6a1521.svg" alt="c" style="vertical-align: 0px"/>)
and <img class="math" src="_images/math/ecfeec93a62e6cd13a536d2d9cc5d030fc64cd36.svg" alt="V_c" style="vertical-align: -3px"/> is the cell volume.</p>
<p>The constructor takes pointers to fields
of density <img class="math" src="_images/math/c0b7d0efa01d88ed6cee9d05c7eb34ab94673410.svg" alt="\rho" style="vertical-align: -4px"/>,
viscosity <img class="math" src="_images/math/9f098d39174fed0d9a72b2b71a93a15d7206caed.svg" alt="\mu" style="vertical-align: -4px"/>,
force <img class="math" src="_images/math/2e98bd810f8898db9973d1651402fcfc80b7ee26.svg" alt="\mathbf{f}" style="vertical-align: 0px"/>
and volume flux <img class="math" src="_images/math/ca0027a941a14f7ca9bceafdb3c555cfb4212487.svg" alt="\mathbf{v} \cdot \mathbf{S}_f" style="vertical-align: -6px"/>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// par: parameters</span>
<span class="c1">// fcr: density</span>
<span class="c1">// ffd: diffusion coefficient</span>
<span class="c1">// fcs: source</span>
<span class="c1">// ffv: volume flux</span>
<span class="n">ConvDiffVect</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">time</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dt</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;</span> <span class="n">m_</span><span class="p">,</span> <span class="k">const</span> <span class="n">EB</span><span class="o">&amp;</span> <span class="n">eb_</span><span class="p">,</span> <span class="n">Par</span> <span class="n">par_</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">fcr</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldFaceb</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">ffd</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;*</span> <span class="n">fcs</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldFaceb</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">ffv</span><span class="p">)</span>
</pre></div>
</div>
<p>After an implementation is constructed, the solution
is advanced by calling <code class="docutils literal notranslate"><span class="pre">MakeIteration()</span></code>
and the current velocity field is returned by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span> <span class="n">GetVelocity</span><span class="p">(</span><span class="n">Step</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</div>
<p>The interface also exposes functions</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">void</span> <span class="n">Assemble</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span> <span class="n">fcw</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldFaceb</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">ffv</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// linear system returned by GetDiag() and GetConst()</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Assemble</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span> <span class="n">fcw</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldFaceb</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">ffv</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// linear system returned by GetDiag() and GetConst()</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Assemble</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span> <span class="n">fcw</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldFaceb</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">ffv</span><span class="p">)</span>
</pre></div>
</div>
<p>to assemble the linear system for a given velocity field
<code class="docutils literal notranslate"><span class="pre">fcw</span></code> from the previous iteration and the volume flux <code class="docutils literal notranslate"><span class="pre">ffv</span></code>
and access its scalar component <code class="docutils literal notranslate"><span class="pre">d</span></code>.
Furthermore, the current solution can be explicitly corrected
with</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">void</span> <span class="n">CorrectVelocity</span><span class="p">(</span><span class="n">Step</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span><span class="p">)</span>
</pre></div>
</div>
<p>Both these features are required for the pressure correction equation.</p>
<div class="section" id="implicit-solver">
<h3><span class="section-number">3.1. </span>Implicit solver<a class="headerlink" href="#implicit-solver" title="Permalink to this headline">¶</a></h3>
<p>Class <code class="docutils literal notranslate"><span class="pre">ConvDiffVectImp</span></code> implements an implicit solver
corresponding to the discrete equation</p>
<div class="math">
<p><img src="_images/math/f203a2984d0c4ec05322e233a36cde34a3ed33d0.svg" alt="\rho_c^s \Big(
\frac{\delta \mathbf{u}_c^{s+1}}{\delta t}
+ \frac{1}{V_c}\sum_{f\in c} v_f^s \mathbf{u}_f^{s+1} S^c_{\!f}
\Big)
= \frac{1}{V_c}\sum_{f\in c} \mu_f^s
  \frac{\delta \mathbf{u}_f^{s+1}}{\delta n} S^c_{\!f}
+ \mathbf{f}_c^s"/></p>
</div><p>which requires solving a linear system at every iteration.</p>
<p>In addition to the requirements of the base class,
the constructor takes mappings describing the boundary
conditions and the initial fields:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ffv: volume flux</span>
<span class="n">ConvDiffVect</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">time</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dt</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;</span> <span class="n">m_</span><span class="p">,</span> <span class="k">const</span> <span class="n">EB</span><span class="o">&amp;</span> <span class="n">eb_</span><span class="p">,</span> <span class="n">Par</span> <span class="n">par_</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">fcr</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldFaceb</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">ffd</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;*</span> <span class="n">fcs</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldFaceb</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">ffv</span><span class="p">)</span>
</pre></div>
</div>
<p>with the initial velocity <code class="docutils literal notranslate"><span class="pre">fcvel</span></code>,
face conditions <code class="docutils literal notranslate"><span class="pre">mfc</span></code>,
cell conditions <code class="docutils literal notranslate"><span class="pre">mcc</span></code>,
density <code class="docutils literal notranslate"><span class="pre">fcr</span></code>,
viscosity <code class="docutils literal notranslate"><span class="pre">fcd</span></code>,
force <code class="docutils literal notranslate"><span class="pre">fcs</span></code>,
and volume flux <code class="docutils literal notranslate"><span class="pre">ffv</span></code>.
Parameters of the solver are provided by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ConvDiffPar</span> <span class="p">{</span>
  <span class="n">Scal</span> <span class="n">relax</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// relaxation factor [0,1] (1 -- no relaxation)</span>
  <span class="kt">bool</span> <span class="n">second</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// second order in time</span>
  <span class="n">ConvSc</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">ConvSc</span><span class="o">::</span><span class="n">quick</span><span class="p">;</span> <span class="c1">// scheme for convective flux (see convdiffi.h)</span>
  <span class="n">Scal</span> <span class="n">df</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// deferred correction factor</span>
  <span class="n">Scal</span> <span class="n">th</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">;</span> <span class="c1">// threshold for flow direction</span>
  <span class="kt">bool</span> <span class="n">stokes</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Stokes flow, disable convective fluxes and time</span>
  <span class="kt">bool</span> <span class="n">symm</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// use symmetric solver for linear system</span>
  <span class="kt">bool</span> <span class="n">explconv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// explicit convective fluxes in case Conv::imp</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">sc</span></code> defines the interpolation scheme</p>
<table class="docutils align-default" id="t-interp-schemes">
<caption><span class="caption-number">Table 3.1 </span><span class="caption-text">Interpolation schemes.</span><a class="headerlink" href="#t-interp-schemes" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 38%" />
<col style="width: 62%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ConvSc::fou</span></code></p></td>
<td><p>First Order Upwind</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ConvSc::cd</span></code></p></td>
<td><p>Central Differences (midpoint)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ConvSc::sou</span></code></p></td>
<td><p>Second Order Upwind</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ConvSc::quick</span></code></p></td>
<td><p>QUICK</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="explicit-solver">
<h3><span class="section-number">3.2. </span>Explicit solver<a class="headerlink" href="#explicit-solver" title="Permalink to this headline">¶</a></h3>
<p>Class <code class="docutils literal notranslate"><span class="pre">ConvDiffVectExp</span></code> implements an explicit solver
corresponding to the discrete equation</p>
<div class="math">
<p><img src="_images/math/04291abdba4a8e16d9b9d9b25e4c2945de9fb79e.svg" alt="\rho_c^s \Big(
\frac{\delta \mathbf{u}_c^{s+1}}{\delta t}
+ \frac{1}{V_c}\sum_{f\in c} v_f^s \mathbf{u}_f^{s} S^c_{\!f}
\Big)
= \frac{1}{V_c}\sum_{f\in c} \mu_f^s
  \frac{\delta \mathbf{u}_f^{s}}{\delta n} S^c_{\!f}
+ \mathbf{f}_c^s."/></p>
</div><p>Here the solution is advanced by explicit formulas
and the linear system is constructed
only to implement <code class="docutils literal notranslate"><span class="pre">Assemble()</span></code> and
<code class="docutils literal notranslate"><span class="pre">GetVelocityEquations()</span></code> of the base class.</p>
</div>
</div>
<span id="document-fluid"></span><div class="section" id="navier-stokes-equations">
<span id="s-fluid"></span><h2><span class="section-number">4. </span>Navier-Stokes equations<a class="headerlink" href="#navier-stokes-equations" title="Permalink to this headline">¶</a></h2>
<p>Abstract class <code class="docutils literal notranslate"><span class="pre">FluidSolver</span></code> describes the interface
of a solver for the Navier-Stokes equations</p>
<div class="math">
<p><img src="_images/math/ea1b7dfa3d8a6f657f1cc3685676a79e84ce2b7e.svg" alt="\nabla \cdot \mathbf{u} &amp;= S_v
\\
\rho \Big(
\frac{\partial \mathbf{u}}{\partial t}
+ (\mathbf{v}\cdot\nabla) \mathbf{u}
\Big)
&amp;=  -\nabla p + \nabla \cdot \mu (\nabla \mathbf{u} + \nabla \mathbf{u}^T)
+ \mathbf{f}"/></p>
</div><p>where the continuity equation is discretized as</p>
<div class="math">
<p><img src="_images/math/9063ce8ec2a9b835dec9899873a09df4346a04a2.svg" alt="\sum_{f\in c} v_f S^c_{\!f} = S_v"/></p>
</div><p>and the momentum equation as <a class="reference internal" href="index.html#equation-e-momentum">(3.1)</a>,
where <img class="math" src="_images/math/932fc7f28603339d20b577290dd0b5cc5f94eb4f.svg" alt="S_v" style="vertical-align: -3px"/> is the volume source term.</p>
<p>The constructor takes pointers to fields
of density <img class="math" src="_images/math/c0b7d0efa01d88ed6cee9d05c7eb34ab94673410.svg" alt="\rho" style="vertical-align: -4px"/>,
viscosity <img class="math" src="_images/math/9f098d39174fed0d9a72b2b71a93a15d7206caed.svg" alt="\mu" style="vertical-align: -4px"/>,
force <img class="math" src="_images/math/2e98bd810f8898db9973d1651402fcfc80b7ee26.svg" alt="\mathbf{f}" style="vertical-align: 0px"/>
and volume source <img class="math" src="_images/math/932fc7f28603339d20b577290dd0b5cc5f94eb4f.svg" alt="S_v" style="vertical-align: -3px"/>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// fcr: density</span>
<span class="c1">// fcd: dynamic viscosity</span>
<span class="c1">// fcf: force</span>
<span class="c1">// febp: projections of balanced force</span>
<span class="c1">// fcsv: volume source</span>
<span class="c1">// fcsm: mass source</span>
<span class="n">FluidSolver</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dt</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;</span> <span class="n">m_</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">fcr</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">fcd</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;*</span> <span class="n">fcf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">febp</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">fcsv</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;*</span> <span class="n">fcsm</span><span class="p">)</span>
</pre></div>
</div>
<p>After an implementation is constructed, the solution
is advanced by calling <code class="docutils literal notranslate"><span class="pre">MakeIteration()</span></code>
and the current solution is provided by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span> <span class="n">GetVelocity</span><span class="p">(</span><span class="n">Step</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">GetPressure</span><span class="p">(</span><span class="n">Step</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="k">const</span> <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">GetVolumeFlux</span><span class="p">(</span><span class="n">Step</span><span class="p">)</span> <span class="k">const</span>
</pre></div>
</div>
<p>The volume flux satisfies the continuity equation
and the cell-based velocity satisfies the momentum equation.</p>
<div class="section" id="simple">
<h3><span class="section-number">4.1. </span>SIMPLE<a class="headerlink" href="#simple" title="Permalink to this headline">¶</a></h3>
<p>Class <code class="docutils literal notranslate"><span class="pre">Simple</span></code> implements the solver using the SIMPLE method.</p>
<p>In addition to the requirements of the base class,
the constructor takes mappings describing the boundary
conditions and the initial fields.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// par: parameters</span>
<span class="n">Simple</span><span class="p">(</span><span class="n">M</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">EB</span><span class="o">&amp;</span> <span class="n">eb</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>with the initial velocity <code class="docutils literal notranslate"><span class="pre">fcw</span></code>,
face conditions <code class="docutils literal notranslate"><span class="pre">mfc</span></code>,
cell conditions <code class="docutils literal notranslate"><span class="pre">mcc</span></code>,
density <code class="docutils literal notranslate"><span class="pre">fcr</span></code>,
viscosity <code class="docutils literal notranslate"><span class="pre">fcd</span></code>,
force <code class="docutils literal notranslate"><span class="pre">fcf</span></code>,
projections of well-balanced force <code class="docutils literal notranslate"><span class="pre">fcbp</span></code>,
volume source <code class="docutils literal notranslate"><span class="pre">fcsv</span></code> and mass source <code class="docutils literal notranslate"><span class="pre">fcsm</span></code>.
Parameters of the solver are provided by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">SimplePar</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">Scal</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Vect</span><span class="o">::</span><span class="n">Scal</span><span class="p">;</span>
  <span class="n">Scal</span> <span class="n">vrelax</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="c1">// velocity relaxation factor [0,1]</span>
  <span class="n">Scal</span> <span class="n">prelax</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// pressure relaxation factor [0,1]</span>
  <span class="n">Scal</span> <span class="n">rhie</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// Rhie-Chow factor [0,1] (0 disable, 1 full)</span>
  <span class="kt">bool</span> <span class="n">second</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// second order in time</span>
  <span class="n">Vect</span> <span class="n">meshvel</span> <span class="o">=</span> <span class="n">Vect</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// relative mesh velocity</span>
  <span class="kt">size_t</span> <span class="n">inletflux_numid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// reduction for id from 0 to numid-1</span>
  <span class="n">ConvSc</span> <span class="n">convsc</span> <span class="o">=</span> <span class="n">ConvSc</span><span class="o">::</span><span class="n">quick</span><span class="p">;</span> <span class="c1">// convection scheme</span>
  <span class="n">Scal</span> <span class="n">convdf</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// deferred correction factor</span>
  <span class="kt">bool</span> <span class="n">stokes</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">explconv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// explicit convection for Conv::imp</span>
  <span class="kt">bool</span> <span class="n">convsymm</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// symmetric solver for linear system in convdiff</span>
  <span class="n">Conv</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">Conv</span><span class="o">::</span><span class="n">imp</span><span class="p">;</span> <span class="c1">// convection-diffusion solver</span>
  <span class="n">Scal</span> <span class="n">outlet_relax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">explviscous</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// enable explicit viscous terms</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="projection">
<h3><span class="section-number">4.2. </span>Projection<a class="headerlink" href="#projection" title="Permalink to this headline">¶</a></h3>
<p>Class <code class="docutils literal notranslate"><span class="pre">Proj</span></code> implements the solver using Chorin’s projection.</p>
<p>In addition to the requirements of the base class,
the constructor takes mappings describing the boundary
conditions and the initial fields.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// par: parameters</span>
<span class="n">Proj</span><span class="p">(</span><span class="n">M</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">EB</span><span class="o">&amp;</span> <span class="n">eb</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>with the initial velocity <code class="docutils literal notranslate"><span class="pre">fcw</span></code>,
face conditions <code class="docutils literal notranslate"><span class="pre">mfc</span></code>,
cell conditions <code class="docutils literal notranslate"><span class="pre">mcc</span></code>,
density <code class="docutils literal notranslate"><span class="pre">fcr</span></code>,
viscosity <code class="docutils literal notranslate"><span class="pre">fcd</span></code>,
force <code class="docutils literal notranslate"><span class="pre">fcf</span></code>,
projections of well-balanced force <code class="docutils literal notranslate"><span class="pre">fcbp</span></code>,
volume source <code class="docutils literal notranslate"><span class="pre">fcsv</span></code> and mass source <code class="docutils literal notranslate"><span class="pre">fcsm</span></code>.
Parameters of the solver are provided by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ProjPar</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">Scal</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Vect</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
  <span class="n">Scal</span> <span class="n">vrelax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// velocity relaxation factor [0,1]</span>
  <span class="n">Scal</span> <span class="n">prelax</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// pressure relaxation factor [0,1]</span>
  <span class="kt">bool</span> <span class="n">second</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// second order in time</span>
  <span class="n">Vect</span> <span class="n">meshvel</span> <span class="o">=</span> <span class="n">Vect</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// relative mesh velocity</span>
  <span class="kt">size_t</span> <span class="n">inletflux_numid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// reduction for id from 0 to numid-1</span>
  <span class="n">ConvSc</span> <span class="n">convsc</span> <span class="o">=</span> <span class="n">ConvSc</span><span class="o">::</span><span class="n">quick</span><span class="p">;</span> <span class="c1">// convection scheme</span>
  <span class="n">Scal</span> <span class="n">convdf</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="c1">// deferred correction factor</span>
  <span class="kt">bool</span> <span class="n">stokes</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Stokes flow</span>
  <span class="kt">bool</span> <span class="n">convsymm</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// symmetric solver for linear system in convdiff</span>
  <span class="n">Conv</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">Conv</span><span class="o">::</span><span class="n">imp</span><span class="p">;</span> <span class="c1">// convection-diffusion solver</span>
  <span class="kt">bool</span> <span class="n">bcg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Bell-Colella-Glaz scheme</span>
  <span class="n">Scal</span> <span class="n">outlet_relax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">Scal</span> <span class="n">inletpressure_factor</span> <span class="o">=</span>
      <span class="mi">0</span><span class="p">;</span> <span class="c1">// correction factor on inlet with given pressure</span>
  <span class="kt">bool</span> <span class="n">explviscous</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// enable explicit viscous terms</span>
  <span class="kt">bool</span> <span class="n">redistr_adv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// use RedistributeCutCellsAdvection()</span>
                            <span class="c1">// if true else RedistributeCutCells()</span>
  <span class="kt">size_t</span> <span class="n">diffusion_iters</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// number of iterations in implicit diffusion</span>
  <span class="kt">bool</span> <span class="n">diffusion_consistent_guess</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="boundary-conditions">
<h3><span class="section-number">4.3. </span>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>The boundary conditions are specified by a map
from <code class="docutils literal notranslate"><span class="pre">IdxFace</span></code> to <code class="docutils literal notranslate"><span class="pre">CondFaceFluid</span></code>,
instances of which can be generated with function <code class="docutils literal notranslate"><span class="pre">solver::Parse()</span></code>
from a string.
Value of <code class="docutils literal notranslate"><span class="pre">id</span></code> is written to field <code class="docutils literal notranslate"><span class="pre">fluidcond</span></code> in <code class="docutils literal notranslate"><span class="pre">bc.vtk</span></code>
(see <a class="reference internal" href="index.html#s-output"><span class="std std-ref">Output</span></a>).</p>
<table class="docutils align-default" id="t-fluid-boundary">
<caption><span class="caption-number">Table 4.1 </span><span class="caption-text">Fluid boundary conditions.</span><a class="headerlink" href="#t-fluid-boundary" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 30%" />
<col style="width: 41%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>class</p></th>
<th class="head"><p>Parse() format</p></th>
<th class="head"><p>description</p></th>
<th class="head"><p>id</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NoSlipWallFixed</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">wall</span> <span class="pre">&lt;x</span> <span class="pre">y</span> <span class="pre">z&gt;</span></code></p></td>
<td><p>no-slip wall with fixed velocity</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">InletFixed</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">inlet</span> <span class="pre">&lt;x</span> <span class="pre">y</span> <span class="pre">z&gt;</span></code></p></td>
<td><p>inlet with given velocity</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">InletFlux</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">inletflux</span> <span class="pre">&lt;x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">id&gt;</span></code></p></td>
<td><p>inlet with given total flux</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">OutletAuto</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">outlet</span></code></p></td>
<td><p>outlet</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SlipWall</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">slipwall</span></code></p></td>
<td><p>free-slip wall</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<span id="document-vofm"></span><div class="section" id="multilayer-vof">
<span id="s-vofm"></span><h2><span class="section-number">5. </span>Multilayer VOF<a class="headerlink" href="#multilayer-vof" title="Permalink to this headline">¶</a></h2>
<p>Multilayer VOF is a method for solving the advection equation
that can represent multiple interfaces in the same cell.
This enables simulations of foams, suspensions,
and other multiphase systems where bubbles and drops that do not coalesce.</p>
<p>The split conservative advection scheme <span id="id1">Weymouth and Yue [<a class="reference internal" href="index.html#id2" title="Gabriel D Weymouth and Dick K-P Yue. Conservative volume-of-fluid method for free-surface simulations on cartesian-grids. Journal of Computational Physics, 229(8):2853–2865, 2010.">1</a>]</span> operates on a volume
fraction field and uses the PLIC reconstruction to compute the fluxes.
In three dimensions, one advection step is split into three sub-steps, or
sweeps. To ensure conservation, a divergence term is added explicitly.
The normals are estimated using the mixed Youngs-centered scheme.</p>
<p>The multilayer VOF implements the same advection scheme
but operates on <em>multilayer fields</em>.
A multilayer field <em>(u,q)</em> stores mappings between <em>colors</em> <em>q</em> and <em>values</em> <em>u</em>.
The colors are real numbers, and <em>none=-1</em> denotes an empty color.
Assuming that each cell can contain at most <em>L=4</em> values,
the mappings are represented as <em>L</em>-tuples up to reordering.
For example, the following tuples encode a field <em>(u,q)</em>
with three values in cell <em>c1</em> and two values in cell <em>c2</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span> <span class="p">{</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span>  <span class="mf">0.1</span><span class="p">,</span>    <span class="mi">0</span><span class="p">}</span>
<span class="n">q</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span> <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>    <span class="mi">2</span><span class="p">,</span> <span class="n">none</span><span class="p">}</span>
<span class="n">u</span><span class="p">[</span><span class="n">c2</span><span class="p">]:</span> <span class="p">{</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">}</span>
<span class="n">q</span><span class="p">[</span><span class="n">c2</span><span class="p">]:</span> <span class="p">{</span>  <span class="mi">1</span><span class="p">,</span>   <span class="mi">2</span><span class="p">,</span> <span class="n">none</span><span class="p">,</span> <span class="n">none</span><span class="p">}</span>
</pre></div>
</div>
<p>The ordering of tuples is insignificant, so simultaneous permutation
of values and colors gives equivalent representations</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span> <span class="p">{</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span>    <span class="mi">0</span><span class="p">}</span>
<span class="n">q</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span> <span class="p">{</span>  <span class="mi">1</span><span class="p">,</span>   <span class="mi">2</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="n">none</span><span class="p">}</span>
<span class="n">u</span><span class="p">[</span><span class="n">c2</span><span class="p">]:</span> <span class="p">{</span><span class="mf">0.7</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span>    <span class="mi">0</span><span class="p">}</span>
<span class="n">q</span><span class="p">[</span><span class="n">c2</span><span class="p">]:</span> <span class="p">{</span>  <span class="mi">2</span><span class="p">,</span> <span class="n">none</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span> <span class="n">none</span><span class="p">}</span>
</pre></div>
</div>
<p>A conventional field can be constructed from a multilayer field
by selecting values with a given color.
For example, selecting the values with color <em>qs=2</em> gives a conventional field
<em>us</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">us</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span> <span class="mi">0</span>
<span class="n">us</span><span class="p">[</span><span class="n">c2</span><span class="p">]:</span> <span class="mf">0.7</span>
</pre></div>
</div>
<p>The following pseudocode implements the multilayer VOF method.
One advection step is split in the spatial directions
and in three dimensions consists of three substeps, or sweeps.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Step</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="nl">d</span> <span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span> <span class="p">{</span>
    <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">}</span> <span class="o">=</span> <span class="n">Sweep</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">{</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">}</span> <span class="o">=</span> <span class="n">Plic</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">q</span> <span class="o">=</span> <span class="n">Recolor</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Given the PLIC reconstruction of the interface,
one sweep computes fluxes, updates the volume fractions
and propagates the colors to downwind cells</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">Sweep</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// v: mixture flux</span>
  <span class="c1">// w: phase flux</span>
  <span class="c1">// qf: phase color from upwind cell</span>
  <span class="k">for</span> <span class="p">(</span><span class="nl">f</span> <span class="p">:</span> <span class="n">faces</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nl">l</span> <span class="p">:</span> <span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">AdjacentCell</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// upwind cell</span>
      <span class="n">w</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">PlicFlux</span><span class="p">(</span><span class="n">n</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">a</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
      <span class="n">qf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

      <span class="n">cd</span> <span class="o">=</span> <span class="n">AdjacentCell</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// downwind cell</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">FindLayer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span> <span class="o">==</span> <span class="n">kLayerNone</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ld</span> <span class="o">=</span> <span class="n">FindLayer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">kClNone</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ld</span> <span class="o">!=</span> <span class="n">kLayerNone</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">q</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">ld</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="nl">c</span> <span class="p">:</span> <span class="n">cells</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nl">l</span> <span class="p">:</span> <span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fm</span> <span class="o">=</span> <span class="n">AdjacentCell</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">fp</span> <span class="o">=</span> <span class="n">AdjacentCell</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">ds</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">fp</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">fm</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">volume</span><span class="p">;</span>
      <span class="n">wm</span> <span class="o">=</span> <span class="n">w</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">FindLayer</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">fm</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)));</span>
      <span class="n">wp</span> <span class="o">=</span> <span class="n">w</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">FindLayer</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)));</span>
      <span class="n">dl</span> <span class="o">=</span> <span class="p">(</span><span class="n">wp</span> <span class="o">-</span> <span class="n">wm</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">vol</span><span class="p">;</span>
      <span class="n">u</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">+=</span> <span class="n">udiv</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds</span> <span class="o">-</span> <span class="n">dl</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">kClNone</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Function <code class="docutils literal notranslate"><span class="pre">Plic()</span></code> builds the PLIC reconstruction in interfacial cells
and returns normals <em>n</em> and plane constants <em>a</em>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">Plic</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="nl">c</span> <span class="p">:</span> <span class="n">cells</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nl">l</span> <span class="p">:</span> <span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uu</span> <span class="o">=</span> <span class="n">Stencil3</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">));</span>
      <span class="n">n</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">(</span><span class="n">uu</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">navg</span> <span class="o">=</span> <span class="n">Avg</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="nl">l</span> <span class="p">:</span> <span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">n</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">navg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">navg</span> <span class="p">:</span> <span class="n">navg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">a</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">PlaneConstant</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">n</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">h</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Normals <em>n</em> are estimated using the standard Youngs-centered scheme <code class="docutils literal notranslate"><span class="pre">Normal()</span></code>
applied to stencil values assembled by <code class="docutils literal notranslate"><span class="pre">Stencil3()</span></code>,
which selects values with given color (or zero if the requested color is not
found) on the <em>3x3x3</em> stencil.
After all advection sweeps,
<code class="docutils literal notranslate"><span class="pre">Recolor()</span></code> detects new connected components
and recomputes the colors as described in <a class="reference internal" href="#s-vofm-recolor"><span class="std std-ref">Connected-component labeling</span></a>.</p>
<p>The complete implementation of the multilayer VOF
is given in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/src/solver/vofm.ipp">src/solver/vofm.ipp</a>.</p>
<div class="section" id="connected-component-labeling">
<span id="s-vofm-recolor"></span><h3><span class="section-number">5.1. </span>Connected-component labeling<a class="headerlink" href="#connected-component-labeling" title="Permalink to this headline">¶</a></h3>
<p>After each advection step, the colors need to be updated to detect new
connected components.  The following function initializes the color field with
unique values, then iteratively joins the colors from adjacent cells by taking
the minimal color until equilibration.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">Recolor</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">q_new</span> <span class="o">=</span> <span class="n">InitUnique</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

  <span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">q_new</span> <span class="o">=</span> <span class="n">RecolorCorners</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q_new</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="nl">c</span> <span class="p">:</span> <span class="n">cells</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="nl">l</span> <span class="p">:</span> <span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="nl">cn</span> <span class="p">:</span> <span class="n">stencil3</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">ln</span> <span class="o">=</span> <span class="n">FindLayer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">));</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ln</span> <span class="o">!=</span> <span class="n">kLayerNone</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">q_new</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">ln</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">q_new</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span> <span class="p">{</span>
              <span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
              <span class="n">q_new</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">q_new</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">ln</span><span class="p">);</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">q_new</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To reduce the number of iterations, function <code class="docutils literal notranslate"><span class="pre">RecolorCorners()</span></code>
runs the same algorithm for corners from cubic subdomains.
The colors propagate through the domain faster.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">RecolorCorners</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q_new</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// map: mapping from old color to new color</span>
  <span class="k">for</span> <span class="p">(</span><span class="nl">c</span> <span class="p">:</span> <span class="n">corners</span> <span class="n">of</span> <span class="n">subdomains</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nl">l</span> <span class="p">:</span> <span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="nl">d</span> <span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span> <span class="p">{</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="n">AdjacentCell</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">ln</span> <span class="o">=</span> <span class="n">FindLayer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">q</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">));</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">q_new</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">q_new</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">ln</span><span class="p">);</span>
        <span class="n">map</span><span class="p">[</span><span class="n">max</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">q1</span> <span class="n">in</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span> <span class="n">in</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">map</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">map</span><span class="p">[</span><span class="n">q1</span><span class="p">]];</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="nl">f</span> <span class="p">:</span> <span class="n">faces</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">AdjacentCell</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">AdjacentCell</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="nl">l</span> <span class="p">:</span> <span class="n">layers</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">q_new</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">q</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">l</span><span class="p">)];</span>
      <span class="n">q_new</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">q</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">l</span><span class="p">)];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">q_new</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-embed"></span><div class="section" id="embedded-boundaries">
<span id="s-embed"></span><h2><span class="section-number">6. </span>Embedded boundaries<a class="headerlink" href="#embedded-boundaries" title="Permalink to this headline">¶</a></h2>
<p>The method of embedded boundaries allows
one to solve equations in complex geometries on a Cartesian mesh.
The surface of a solid body is represented by <em>cut cells</em>.
A cut cell is obtained by cutting a regular cubic cell with a plane.
Discretization of the equations with the finite volume method
remains the same, except that the discrete conservation law now includes
additional boundaries in cut cells.</p>
<p>The functionality related to embedded boundaries is provided in header
<code class="docutils literal notranslate"><span class="pre">embed.h</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;aphros/solver/embed.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>A new type <code class="docutils literal notranslate"><span class="pre">FieldEmbed</span></code> transparently combines <code class="docutils literal notranslate"><span class="pre">FieldFace</span></code> and
<code class="docutils literal notranslate"><span class="pre">FieldCell</span></code>.
The cell-field stores the values on embedded boundaries.
Given a mesh <code class="docutils literal notranslate"><span class="pre">m</span></code>,
a combined field is initialized on the mesh similar to other fields
with an optional default value:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fe</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// [f]ield [e]mbed</span>
</pre></div>
</div>
<p>The field can be accessed both by cell- and face-indices.
The following code traverses all internal cells and faces and assigns a
value to the field:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">IdxCell</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">m</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">fe</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">IdxFace</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">m</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">fe</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A new class <code class="docutils literal notranslate"><span class="pre">Embed&lt;M&gt;</span></code> defines
new iterators and geometric routines that take into account cut cells.
The cells and faces are divided into three groups:</p>
<ul class="simple">
<li><p>regular cells (whole cells inside the domain),</p></li>
<li><p>cut cells (cells crossed by the domain boundary),</p></li>
<li><p>excluded cells (cells outside the domain).</p></li>
</ul>
<p>The same classification applies to faces</p>
<ul class="simple">
<li><p>regular faces (whole faces inside the domain),</p></li>
<li><p>cut faces (faces crossed by the domain boundary),</p></li>
<li><p>excluded faces (cells outside the domain).</p></li>
</ul>
<p>An instance of <code class="docutils literal notranslate"><span class="pre">Embed&lt;M&gt;</span></code>, commonly named as <code class="docutils literal notranslate"><span class="pre">eb</span></code>, is constructed from a
mesh and needs to be initialized from a level-set function <img class="math" src="_images/math/8d9b14aeca4e684f95219c829a2852fe7f73e17d.svg" alt="\varphi" style="vertical-align: -4px"/>
stored in a node-field:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">const</span> <span class="n">FieldNode</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">phi</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">sem</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">GetSem</span><span class="p">();</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span> <span class="n">eb_</span><span class="p">;</span>
  <span class="p">}</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">eb_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">.</span><span class="n">Nested</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">eb_</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Regular cells are those for which <img class="math" src="_images/math/c779d61fc28471b765cbd8c6f8cd3269cf8be077.svg" alt="\varphi&gt;0" style="vertical-align: -4px"/> in all adjacent nodes,
excluded cells are those for which <img class="math" src="_images/math/76f8c51e2d64bec5df42f3de4812fa82666897ff.svg" alt="\varphi&lt;0" style="vertical-align: -4px"/> in all adjacent nodes,
and other cells are cut cells.
The <code class="docutils literal notranslate"><span class="pre">Embed&lt;M&gt;</span></code> class defines ranges <code class="docutils literal notranslate"><span class="pre">eb.Cells()</span></code> and <code class="docutils literal notranslate"><span class="pre">eb.Faces()</span></code>
such that they include regular and cut cells but not excluded cells.
Another range <code class="docutils literal notranslate"><span class="pre">eb.CFaces()</span></code> traverses only cut cells.
The name <code class="docutils literal notranslate"><span class="pre">CFaces</span></code> comes from <em>Cell Faces</em>.
Together, <code class="docutils literal notranslate"><span class="pre">eb.Faces()</span></code> and <code class="docutils literal notranslate"><span class="pre">eb.CFaces()</span></code> include all indices
for which an embed-field can be defined.
The following code assigns a value to the embed-field
in cut cells, regular faces and cut faces:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">IdxCell</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">CFaces</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">fe</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">IdxFace</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">fe</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Class <code class="docutils literal notranslate"><span class="pre">Embed&lt;M&gt;</span></code> also defines geometric routines
such as <code class="docutils literal notranslate"><span class="pre">eb.GetVolume()</span></code> and <code class="docutils literal notranslate"><span class="pre">eb.GetArea()</span></code>.
The following code computes the total volume of the domain
and the total area of all boundaries:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Scal</span> <span class="n">vol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">IdxCell</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">vol</span> <span class="o">+=</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Scal</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">IdxFace</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">area</span> <span class="o">+=</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetArea</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">IdxCell</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">CFaces</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">area</span> <span class="o">+=</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetArea</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The range of neighbor indices <code class="docutils literal notranslate"><span class="pre">eb.Nci()</span></code> is limited to non-excluded neighbor
faces.  The name <code class="docutils literal notranslate"><span class="pre">Nci</span></code> stands for <em>Neighbor Cell Index</em>.
The following code sums up the values over all faces of one cut cell <code class="docutils literal notranslate"><span class="pre">c</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">IdxCell</span> <span class="n">c</span><span class="p">;</span>
<span class="n">Scal</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fe</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Nci</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">IdxFace</span> <span class="n">f</span> <span class="o">=</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetFace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">fe</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The header defines numerical routines for interpolation
and computation of gradients. Some of them require boundary conditions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MapEmbedCond</span> <span class="n">mec</span><span class="p">;</span> <span class="c1">// boundary conditions</span>
<span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">feu</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fcu</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fci</span> <span class="o">=</span> <span class="n">eb</span><span class="p">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">feu</span><span class="p">);</span>
<span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fei</span> <span class="o">=</span> <span class="n">eb</span><span class="p">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mec</span><span class="p">);</span>
<span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;</span> <span class="n">fcg</span> <span class="o">=</span> <span class="n">eb</span><span class="p">.</span><span class="n">Gradient</span><span class="p">(</span><span class="n">feu</span><span class="p">);</span>
<span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">feg</span> <span class="o">=</span> <span class="n">eb</span><span class="p">.</span><span class="n">Gradient</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mec</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="advection-solver">
<span id="s-embed-advection"></span><h3><span class="section-number">6.1. </span>Advection solver<a class="headerlink" href="#advection-solver" title="Permalink to this headline">¶</a></h3>
<p>The routines described above are sufficient to implement an advection solver.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Advection solver.</span>
<span class="c1">// fcu: quantity to advect</span>
<span class="c1">// mebc: boundary conditions</span>
<span class="c1">// vel: advection velocity</span>
<span class="c1">// dt: time step</span>
<span class="kt">void</span> <span class="nf">Advection0</span><span class="p">(</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fcu</span><span class="p">,</span> <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="n">BCond</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&gt;&amp;</span> <span class="n">mebc</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fev</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">dt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span> <span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">fcg</span> <span class="o">=</span>
      <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">GradientLinearFit</span><span class="p">(</span><span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">eb</span><span class="p">),</span> <span class="n">eb</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">feu</span> <span class="o">=</span>
      <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">InterpolateUpwind</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">ConvSc</span><span class="o">::</span><span class="n">fou</span><span class="p">,</span> <span class="n">fcg</span><span class="p">,</span> <span class="n">fev</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Compute flux.</span>
  <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fevu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fevu</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">feu</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">*</span> <span class="n">fev</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">CFaces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fevu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">feu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">fev</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="c1">// Advance in time.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Scal</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fevu</span><span class="p">[</span><span class="n">c</span><span class="p">];</span> <span class="c1">// sum of fluxes</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Nci</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">fevu</span><span class="p">[</span><span class="n">eb</span><span class="p">.</span><span class="n">GetFace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetOutwardFactor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fcu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-center" id="t-results-of-advection">
<caption><span class="caption-number">Table 6.1 </span><span class="caption-text">Results of advection solver <code class="docutils literal notranslate"><span class="pre">Advection0()</span></code>: initial (left) and final (right). Instabilities develop near the boundary.</span><a class="headerlink" href="#t-results-of-advection" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex103_0_0" src="_images/u_0000.svg" /></p></td>
<td><p><img alt="ex103_0_1" src="_images/u_0001.svg" /></p></td>
</tr>
</tbody>
</table>
<p>See full example in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/103_embed_advection/main.cpp">examples/103_embed_advection/main.cpp</a>.</p>
<p>The previous implementation suffers from the problem of small cells.
Stability requires that the change of the conserved quantity at one time
step does not exceed the cell volume.
Therefore, small cells lead to strong restrictions on the time step.
One common remedy is redistribution of the conserved quantity
to neighboring cells.
Function <code class="docutils literal notranslate"><span class="pre">eb.RedistributeCutCells()</span></code> redistributes a conserved quantity
from cut cells to their neighboring cells such that the integral of the
quantity does not change.
Using this function in the advection solver results in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Advection solver with redistribution from cut cells</span>
<span class="c1">// and first order upwind scheme.</span>
<span class="kt">void</span> <span class="nf">Advection1</span><span class="p">(</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fcu</span><span class="p">,</span> <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="n">BCond</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&gt;&amp;</span> <span class="n">mebc</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fev</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">dt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span> <span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">fcg</span> <span class="o">=</span>
      <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">GradientLinearFit</span><span class="p">(</span><span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">eb</span><span class="p">),</span> <span class="n">eb</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">feu</span> <span class="o">=</span>
      <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">InterpolateUpwind</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">ConvSc</span><span class="o">::</span><span class="n">fou</span><span class="p">,</span> <span class="n">fcg</span><span class="p">,</span> <span class="n">fev</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Compute flux.</span>
  <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fevu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fevu</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">feu</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">*</span> <span class="n">fev</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">CFaces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fevu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">feu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">fev</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="c1">// Compute the change at one time step.</span>
  <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fct</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Scal</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fevu</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Nci</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">fevu</span><span class="p">[</span><span class="n">eb</span><span class="p">.</span><span class="n">GetFace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetOutwardFactor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sum</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fct</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">RedistributeCutCells</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Advance in time.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fcu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Advection solver with redistribution from cut cells</span>
<span class="c1">// and second order upwind scheme.</span>
<span class="kt">void</span> <span class="nf">Advection2</span><span class="p">(</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fcu</span><span class="p">,</span> <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="n">BCond</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&gt;&amp;</span> <span class="n">mebc</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fev</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">dt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span> <span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">fcg</span> <span class="o">=</span>
      <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">GradientLinearFit</span><span class="p">(</span><span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">eb</span><span class="p">),</span> <span class="n">eb</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">feu</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">InterpolateUpwind</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">ConvSc</span><span class="o">::</span><span class="n">sou</span><span class="p">,</span> <span class="n">fcg</span><span class="p">,</span> <span class="n">fev</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Compute flux.</span>
  <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fevu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fevu</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">feu</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">*</span> <span class="n">fev</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">CFaces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fevu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">feu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">fev</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="c1">// Compute the change at one time step.</span>
  <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fct</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Scal</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fevu</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Nci</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">fevu</span><span class="p">[</span><span class="n">eb</span><span class="p">.</span><span class="n">GetFace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetOutwardFactor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sum</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fct</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">RedistributeCutCells</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Advance in time.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fcu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-center" id="t-results-of-first0">
<caption><span class="caption-number">Table 6.2 </span><span class="caption-text">Results of first order upwind scheme <code class="docutils literal notranslate"><span class="pre">Advection1()</span></code>
        (left) and second order upwind scheme <code class="docutils literal notranslate"><span class="pre">Advection2()</span></code>
        (right). Resdistribution from cut cells stabilizes the
        method in both cases.</span><a class="headerlink" href="#t-results-of-first0" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex103_1_1" src="_images/u_00011.svg" /></p></td>
<td><p><img alt="ex103_2_1" src="_images/u_00012.svg" /></p></td>
</tr>
</tbody>
</table>
<p>The fraction of redistributed quantities <code class="docutils literal notranslate"><span class="pre">eb.RedistributeCutCells()</span></code> does not
depend on the velocity or the time step.  While this makes a stable method,
the unnecessary redistribution of values may reduce the accuracy.
Another approach would be to use a local stability criterion
depending on the velocity</p>
<div class="math">
<p><img src="_images/math/be7431c6d27b409ca9ab002347e99b86e9148410.svg" alt="\frac{v_f \Delta t}{S_f |\mathbf{x}_c - \mathbf{x}_f|} &lt; \texttt{CFL}_0"/></p>
</div></div>
<div class="section" id="diffusion-solver">
<h3><span class="section-number">6.2. </span>Diffusion solver<a class="headerlink" href="#diffusion-solver" title="Permalink to this headline">¶</a></h3>
<p>The diffusion equation illustrates another problem of small cells which arises
in computation of gradients.
The diffusive fluxes are proportional to the normal gradient of the quantity.
Approximations of normal gradients contain the distance
between the face and cell centroids in the denominator.</p>
<div class="math">
<p><img src="_images/math/022502aadab0bff92908834a0b99a629390ea505.svg" alt="\Big(\frac{\delta u}{\delta n}\Big) =
\frac{u_c - u_f}{(\mathbf{x}_c - \mathbf{x}_f) \cdot \mathbf{n}_f}"/></p>
</div><p>The following function implements a diffusion solver using this approximation</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Diffusion solver.</span>
<span class="c1">// fcu: quantity to advect</span>
<span class="c1">// mebc: boundary conditions</span>
<span class="c1">// diff: diffusion coefficient</span>
<span class="c1">// dt: time step</span>
<span class="kt">void</span> <span class="nf">Diffusion0</span><span class="p">(</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fcu</span><span class="p">,</span> <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="n">BCond</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&gt;&amp;</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">dt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span> <span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">feg</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">Gradient</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Compute flux.</span>
  <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fed</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fed</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">feg</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetArea</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">CFaces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fed</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">feg</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetArea</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Advance in time.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Scal</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fed</span><span class="p">[</span><span class="n">c</span><span class="p">];</span> <span class="c1">// sum of fluxes</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Nci</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">fed</span><span class="p">[</span><span class="n">eb</span><span class="p">.</span><span class="n">GetFace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetOutwardFactor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fcu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-center" id="t-results-of-diffusion0">
<caption><span class="caption-number">Table 6.3 </span><span class="caption-text">Results of diffusion solver <code class="docutils literal notranslate"><span class="pre">Diffusion0()</span></code>: initial
        (left) and final (right). Instabilities develop near the
        boundary.</span><a class="headerlink" href="#t-results-of-diffusion0" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex104_0_0" src="_images/u_00001.svg" /></p></td>
<td><p><img alt="ex104_0_1" src="_images/u_00013.svg" /></p></td>
</tr>
</tbody>
</table>
<p>See full example in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/104_embed_diffusion/main.cpp">examples/104_embed_diffusion/main.cpp</a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Diffusion solver with redistribution to neighbor cells.</span>
<span class="kt">void</span> <span class="nf">Diffusion1</span><span class="p">(</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fcu</span><span class="p">,</span> <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="n">BCond</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&gt;&amp;</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">dt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span> <span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">feg</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">Gradient</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Compute flux.</span>
  <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fed</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fed</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">feg</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetArea</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">CFaces</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fed</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">feg</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetArea</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Compute the change at one time step.</span>
  <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fct</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Scal</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fed</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Nci</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">fed</span><span class="p">[</span><span class="n">eb</span><span class="p">.</span><span class="n">GetFace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetOutwardFactor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fct</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">RedistributeCutCells</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Advance in time.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fcu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Diffusion solver with redistribution to neighbor cells</span>
<span class="c1">// and LoopFaces() to avoid code duplicatoin.</span>
<span class="kt">void</span> <span class="nf">Diffusion2</span><span class="p">(</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">fcu</span><span class="p">,</span> <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="n">BCond</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&gt;&amp;</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Scal</span> <span class="n">dt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Embed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span> <span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">feg</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">Gradient</span><span class="p">(</span><span class="n">fcu</span><span class="p">,</span> <span class="n">mebc</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Compute flux.</span>
  <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fed</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">eb</span><span class="p">.</span><span class="n">LoopFaces</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">cf</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// lambda-function applied to faces and</span>
                              <span class="c1">// embedded faces</span>
    <span class="n">fed</span><span class="p">[</span><span class="n">cf</span><span class="p">]</span> <span class="o">=</span> <span class="n">feg</span><span class="p">[</span><span class="n">cf</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetArea</span><span class="p">(</span><span class="n">cf</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="c1">// Compute the change at one time step.</span>
  <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fct</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Scal</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fed</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">q</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Nci</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">fed</span><span class="p">[</span><span class="n">eb</span><span class="p">.</span><span class="n">GetFace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">)]</span> <span class="o">*</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetOutwardFactor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fct</span> <span class="o">=</span> <span class="n">UEmbed</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">RedistributeCutCells</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
  <span class="c1">// Advance in time.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">eb</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">fcu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fct</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="n">eb</span><span class="p">.</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<table class="docutils align-center" id="t-results-of-diffusion1">
<caption><span class="caption-number">Table 6.4 </span><span class="caption-text">Results of diffusion solver <code class="docutils literal notranslate"><span class="pre">Diffusion1()</span></code> (left) using
        linear fit to cell centers to compute the gradient which
        eliminates the instabilities.  Solver <code class="docutils literal notranslate"><span class="pre">Diffusion2()</span></code>
        (right) produces the same results and illustrates the usage
        of <code class="docutils literal notranslate"><span class="pre">ExecFaces()</span></code> to execute the same lambda-function on
        indices of two types</span><a class="headerlink" href="#t-results-of-diffusion1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 52%" />
<col style="width: 48%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex104_1_1" src="_images/u_00014.svg" /></p></td>
<td><p><img alt="ex104_2_1" src="_images/u_00015.svg" /></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="taylor-couette-flow">
<h3><span class="section-number">6.3. </span>Taylor-Couette flow<a class="headerlink" href="#taylor-couette-flow" title="Permalink to this headline">¶</a></h3>
<p>See full example in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/201_taylor_couette">examples/201_taylor_couette</a>.</p>
<table class="docutils align-center" id="t-error-norms">
<caption><span class="caption-number">Table 6.5 </span><span class="caption-text">Error norms with grid refinement (left) and error field at <img class="math" src="_images/math/e0aee9e6904d698bbcbeb4c7cc4dca52d34d67d9.svg" alt="R/h=25.6" style="vertical-align: -5px"/> (right).</span><a class="headerlink" href="#t-error-norms" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex201_error" src="_images/error.svg" /></p></td>
<td><p><img alt="ex201_field" src="_images/field.svg" /></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hydrostatic">
<h3><span class="section-number">6.4. </span>Hydrostatic<a class="headerlink" href="#hydrostatic" title="Permalink to this headline">¶</a></h3>
<div class="section" id="single-phase">
<h4><span class="section-number">6.4.1. </span>Single-phase<a class="headerlink" href="#single-phase" title="Permalink to this headline">¶</a></h4>
<p>See full example in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/203_hydrostatic">examples/203_hydrostatic</a>.</p>
<table class="docutils align-center" id="t-pressure">
<caption><span class="caption-number">Table 6.6 </span><span class="caption-text">Pressure (left) and velocity (right).</span><a class="headerlink" href="#t-pressure" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex203_pressure" src="_images/pressure.svg" /></p></td>
<td><p><img alt="ex203_velocity" src="_images/velocity.svg" /></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="multiphase">
<h4><span class="section-number">6.4.2. </span>Multiphase<a class="headerlink" href="#multiphase" title="Permalink to this headline">¶</a></h4>
<p>See full example in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/203_hydrostatic">examples/203_hydrostatic</a>.</p>
<table class="docutils align-center" id="t-density">
<caption><span class="caption-number">Table 6.7 </span><span class="caption-text">Initial density (top left), final density (top right), pressure (bottom left) and velocity (bottom right).</span><a class="headerlink" href="#t-density" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 56%" />
<col style="width: 44%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex203m_density_init" src="_images/density_init.svg" /></p>
<p><img alt="ex203m_pressure" src="_images/pressure1.svg" /></p>
</td>
<td><p><img alt="ex203m_density" src="_images/density.svg" /></p>
<p><img alt="ex203m_velocity" src="_images/velocity1.svg" /></p>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-center" id="t-evolution">
<caption><span class="caption-number">Table 6.8 </span><span class="caption-text">Evolution of velocity norms.</span><a class="headerlink" href="#t-evolution" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><img alt="ex203m_history" src="_images/history.svg" /></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<span id="document-primlist"></span><div class="section" id="geometric-primitives">
<span id="s-primlist"></span><h2><span class="section-number">7. </span>Geometric primitives<a class="headerlink" href="#geometric-primitives" title="Permalink to this headline">¶</a></h2>
<p>Header <code class="docutils literal notranslate"><span class="pre">func/primlist.h</span></code> provides routines to define level-set functions
for a list of geometric primitives such as spheres and boxes.
A primitive is described by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Primitive</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">Vect</span> <span class="o">=</span> <span class="n">Vect_</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">Scal</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Vect</span><span class="o">::</span><span class="n">Scal</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">Vect</span><span class="o">::</span><span class="n">dim</span><span class="p">;</span>

  <span class="n">Primitive</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name_</span><span class="p">),</span> <span class="n">inter</span><span class="p">([](</span><span class="k">const</span> <span class="n">Rect</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">})</span> <span class="p">{}</span>
  <span class="n">Primitive</span><span class="p">()</span> <span class="o">:</span> <span class="n">Primitive</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">Primitive</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">o</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;name=&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span><span class="p">;</span>
    <span class="n">o</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; mod=&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">mod_minus</span> <span class="o">?</span> <span class="s">&quot;-&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">mod_and</span> <span class="o">?</span> <span class="s">&quot;&amp;&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">mod_minus</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">mod_and</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Scal</span><span class="p">(</span><span class="k">const</span> <span class="n">Vect</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ls</span><span class="p">;</span> <span class="c1">// level-set</span>
  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">inter</span><span class="p">;</span> <span class="c1">// true if intersects rectangle</span>
  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Vect</span><span class="p">(</span><span class="k">const</span> <span class="n">Vect</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">velocity</span><span class="p">;</span> <span class="c1">// velocity</span>

  <span class="n">Vect</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// center XXX adhoc for GetSphereOverlap</span>
  <span class="n">Vect</span> <span class="n">r</span><span class="p">;</span> <span class="c1">// radius XXX adhoc for GetSphereOverlap</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Function <code class="docutils literal notranslate"><span class="pre">GetPrimitives()</span></code> parses a stream with a list of primitives.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Parses a list of primitives in stream buf.</span>
  <span class="c1">// edim: effective dimension, 2 or 3 (ignores z-component if edim=2)</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Primitive</span><span class="o">&gt;</span> <span class="n">GetPrimitives</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">edim</span><span class="p">)</span>
</pre></div>
</div>
<p>Available primitives and their parameters:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sphere</span></code></dt><dd><p>Ellipsoid with principal axes aligned with the coordinate axes.
Parameters:
<code class="docutils literal notranslate"><span class="pre">cx</span> <span class="pre">cy</span> <span class="pre">cz</span></code> (center), <code class="docutils literal notranslate"><span class="pre">rx</span> <span class="pre">ry</span> <span class="pre">rz</span></code> (half-size);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">box</span></code></dt><dd><p>Rectangular box with sides aligned with the coordinate planes.
Parameters:
<code class="docutils literal notranslate"><span class="pre">cx</span> <span class="pre">cy</span> <span class="pre">cz</span></code> (center), <code class="docutils literal notranslate"><span class="pre">rx</span> <span class="pre">ry</span> <span class="pre">rz</span></code> (half-size);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ring</span></code></dt><dd><p>Torus.
Parameters:
<code class="docutils literal notranslate"><span class="pre">cx</span> <span class="pre">cy</span> <span class="pre">cz</span></code> (center), <code class="docutils literal notranslate"><span class="pre">nx</span> <span class="pre">ny</span> <span class="pre">nz</span></code> (normal), <code class="docutils literal notranslate"><span class="pre">r</span></code> (radius), <code class="docutils literal notranslate"><span class="pre">th</span></code> (thickness);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">smooth_step</span></code></dt><dd><p>Smooth step <span id="id1">Almgren <em>et al.</em> [<a class="reference internal" href="index.html#id3" title="Ann S Almgren, John B Bell, Phillip Colella, and Tyler Marthaler. A cartesian grid projection method for the incompressible euler equations in complex geometries. SIAM Journal on Scientific Computing, 18(5):1289–1309, 1997.">2</a>]</span>.
Parameters:
<code class="docutils literal notranslate"><span class="pre">cx</span> <span class="pre">cy</span> <span class="pre">cz</span></code> (center), <code class="docutils literal notranslate"><span class="pre">nx</span> <span class="pre">ny</span> <span class="pre">nz</span></code> (normal), <code class="docutils literal notranslate"><span class="pre">tx</span> <span class="pre">ty</span> <span class="pre">tz</span></code> (tangent),
<code class="docutils literal notranslate"><span class="pre">ln</span></code> (size along normal), <code class="docutils literal notranslate"><span class="pre">lt</span></code> (size along tangent);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cylinder</span></code></dt><dd><p>Right circular cylinder.
Parameters:
<code class="docutils literal notranslate"><span class="pre">cx</span> <span class="pre">cy</span> <span class="pre">cz</span></code> (center), <code class="docutils literal notranslate"><span class="pre">nx</span> <span class="pre">ny</span> <span class="pre">nz</span></code> (normal), <code class="docutils literal notranslate"><span class="pre">r</span></code> (radius),
<code class="docutils literal notranslate"><span class="pre">n0</span> <span class="pre">n1</span></code> (range along normal relative to center);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">polygon</span></code></dt><dd><p>Cylinder bounded by parallel planes with the plane section specified as a
sequence of non-intersecting polygons.
Parameters:
<code class="docutils literal notranslate"><span class="pre">ox</span> <span class="pre">oy</span> <span class="pre">oz</span></code> (origin), <code class="docutils literal notranslate"><span class="pre">nx</span> <span class="pre">ny</span> <span class="pre">nz</span></code> (normal), <code class="docutils literal notranslate"><span class="pre">ux</span> <span class="pre">uy</span> <span class="pre">uz</span></code>
(direction of 2D x-axis), <code class="docutils literal notranslate"><span class="pre">n0</span> <span class="pre">n1</span></code> (range along normal relative to origin),
<code class="docutils literal notranslate"><span class="pre">scale</span></code> (factor applied to 2D vertices), <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">...</span></code>
(2D vertices of all polygons, first and last vertices of each polygon must
coincide);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ruled</span></code></dt><dd><p>Ruled surface bounded by parallel planes with two plane sections
on the opposite sides specified as two sequences of non-intersecting polygons.
Parameters:
<code class="docutils literal notranslate"><span class="pre">ox</span> <span class="pre">oy</span> <span class="pre">oz</span></code> (origin), <code class="docutils literal notranslate"><span class="pre">nx</span> <span class="pre">ny</span> <span class="pre">nz</span></code> (normal), <code class="docutils literal notranslate"><span class="pre">ux</span> <span class="pre">uy</span> <span class="pre">uz</span></code> (direction of 2D
x-axis), <code class="docutils literal notranslate"><span class="pre">n0</span> <span class="pre">n1</span></code> (range along normal relative to origin, sides 0 and 1),
<code class="docutils literal notranslate"><span class="pre">scale0</span> <span class="pre">scale1</span></code>
(factors applied to 2D vertices on sides 0 and 1), <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">...</span></code>
(2D vertices of all polygons on side 0, first and last vertices of
each polygon must coincide), <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">...</span></code> (same but on side 1).</p>
</dd>
</dl>
<p>Each primitive defines a level-set function which is positive inside the body.
By default, the resulting level-set function is composed from the list of
primitives using the union operation (taking the maximum value).
To change the default operation, modifiers can be added
before the name of the primitive:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-</span></code>: minus, multiply level-set by -1;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code>: intersection, take the minimum with the current level-set.</p></li>
</ul>
<p>Example of a list of primitives</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cx cy cz   rx ry rz
box 0.7 0.3 0.4   0.25 0.2 0.15

&amp;cylinder 0.55 0.25 0.5   0 0 1   0.22   -1 1
&amp;-cylinder 0.7 0.3 0.4   1 0.5 0   0.07   -1 1

# cx cy cz   rx ry rz
sphere 0.3 0.3 0.7   0.25 0.2 0.15

&amp;-box 0.45 0.3 0.7   0.1 0.2 0.03

# cx cy cz nx   ny nz r th
ring 0.3 0.7 0.5   0 1 0.5   0.15  0.05

# cx cy cz   nx ny nz   tx ty tz   ln lt
smooth_step 0.5 0.5 0.1   0 0 1   0 1 0   0.05   0.1

# cx cy cz   tx ty tz   r   t0 t1
cylinder 0.75 0.7 0.3   -2 1 0.5   0.1   -0.2 0.2

-sphere 1 0.2 0   1.3
&amp;-cylinder 0.1 0.8 0.8   -2 1 0.5   0.1   -0.2 0.2
</pre></div>
</div>
<p>(see setup in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/200_primlist">examples/200_primlist</a>)</p>
<a class="reference internal image-reference" href="_images/a_orig.jpg"><img alt="_images/a_orig.jpg" class="align-center" src="_images/a_orig.jpg" style="width: 400px;" /></a>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">list_ls</span></code> in the configuration defines the
method of computing the volume fraction field from the level-set functions</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">int</span> <span class="pre">list_ls</span> <span class="pre">0</span></code></dt><dd><p>step-wise approximation (1 if level-set is positive, 0 otherwise);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">int</span> <span class="pre">list_ls</span> <span class="pre">1</span></code></dt><dd><p>linear approximation with normal and plane constant
computed from the level-set at the cell center,
does not support modifiers;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">int</span> <span class="pre">list_ls</span> <span class="pre">2</span></code></dt><dd><p>using the <code class="docutils literal notranslate"><span class="pre">overlap</span></code> library to compute the exact
volume fraction cut by an ellipsoid (only valid for primitive <code class="docutils literal notranslate"><span class="pre">sphere</span></code>);</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">int</span> <span class="pre">list_ls</span> <span class="pre">3</span></code></dt><dd><p>linear approximation with normal and plane constant
computed from the level-set on mesh nodes, supports modifiers.</p>
</dd>
</dl>
</div>
<span id="document-bclist"></span><div class="section" id="boundary-conditions">
<span id="s-bclist"></span><h2><span class="section-number">8. </span>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>Header <code class="docutils literal notranslate"><span class="pre">func/init_u.h</span></code> provides routines to describe boundary
conditions based on primitives.
The list of boundary conditions is a list of code blocks with primitives.</p>
<div class="section" id="code-blocks">
<h3><span class="section-number">8.1. </span>Code blocks<a class="headerlink" href="#code-blocks" title="Permalink to this headline">¶</a></h3>
<p>A code block is described by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">CodeBlock</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">content</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and has the following format</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NAME {
  CONTENT
}
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">NAME</span></code> does not contain <code class="docutils literal notranslate"><span class="pre">{</span></code> or <code class="docutils literal notranslate"><span class="pre">}</span></code>
and <code class="docutils literal notranslate"><span class="pre">CONTENT</span></code> may contain only matching <code class="docutils literal notranslate"><span class="pre">{...}</span></code>.</p>
<p>Examples of code blocks</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>name {
  content
}

name { content }

name with spaces {
  content { inside {inside} braces }
}

</pre></div>
</div>
<p>The following function extracts a list of blocks from a stream</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Parses a stream and returns a list of code blocks.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CodeBlock</span><span class="o">&gt;</span> <span class="n">ParseCodeBlocks</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Leading and trailing whitespaces are stripped.</p>
</div>
<div class="section" id="groups-of-primitives">
<h3><span class="section-number">8.2. </span>Groups of primitives<a class="headerlink" href="#groups-of-primitives" title="Permalink to this headline">¶</a></h3>
<p>Boundary conditions are selected inside groups of primitives
organized as code blocks.
The name of the block is the boundary condition to set
and the content is a list of primitives
describing a single level set function.
Affected are cut cells and faces on the domain boundary.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>wall 0 0 0 {
  box 0 0 0 10
}
wall 1 0 0 {
  sphere 0.7 0.5 0.5 0.2
}
slipwall {
  sphere 0.3 0.5 0.5 0.2
}
inlet 1 0 0 {
  sphere 0.5 0.7 0.5 0.2
}
symm {
  sphere 0.5 0.5 0.7 0.2
  sphere 0.5 0.5 0.3 0.2
}
</pre></div>
</div>
<p>The following function parses parses a file
and returns a <code class="docutils literal notranslate"><span class="pre">MapEmbed</span></code> object containing face and cut-cell conditions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>    <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span>
<span class="n">ParseGroups</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">fin</span><span class="p">,</span> <span class="k">const</span> <span class="n">MEB</span><span class="o">&amp;</span> <span class="n">eb</span><span class="p">,</span> <span class="k">const</span> <span class="n">FieldCell</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">fc_innermask</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-output"></span><div class="section" id="output">
<span id="s-output"></span><h2><span class="section-number">9. </span>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>Simulations produce output of various types:</p>
<ul class="simple">
<li><p>statistics (stdout)</p></li>
<li><p>fields (HDF5, plain or XML VTK)</p></li>
<li><p>PLIC polygons (polydata legacy VTK)</p></li>
<li><p>marching cubes triangles (polydata legacy VTK)</p></li>
<li><p>boundary conditions (polydata legacy VTK)</p></li>
</ul>
<p>Boundary conditions are written to <code class="docutils literal notranslate"><span class="pre">bc.vtk</span></code> if enabled by <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">int</span>
<span class="pre">dumpbc</span> <span class="pre">1</span></code>.  It contains cell fields <code class="docutils literal notranslate"><span class="pre">block</span></code> (block id), <code class="docutils literal notranslate"><span class="pre">cond</span></code>
(conditions for advection) and <code class="docutils literal notranslate"><span class="pre">condfluid</span></code> (conditions for fluid,
see <a class="reference internal" href="index.html#t-fluid-boundary"><span class="std std-ref">Fluid boundary conditions.</span></a>).</p>
<p>The output is implemented in function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">DumpBcPoly</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span> <span class="n">me_group</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">MEB</span><span class="o">::</span><span class="n">Scal</span><span class="o">&gt;&amp;</span> <span class="n">me_contang</span><span class="p">,</span> <span class="k">const</span> <span class="n">MEB</span><span class="o">&amp;</span> <span class="n">meb</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">MEB</span><span class="o">::</span><span class="n">M</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-lib1/index"></span><div class="section" id="tools">
<h2><span class="section-number">10. </span>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-lib1/ap-cawk"></span><div class="section" id="awk-for-csv-files">
<h3><span class="section-number">10.1. </span>AWK for CSV files<a class="headerlink" href="#awk-for-csv-files" title="Permalink to this headline">¶</a></h3>
<div class="section" id="synopsis">
<h4><span class="section-number">10.1.1. </span>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h4>
<p>ap.cawk [-v var=value] [‘prog’] [CSV ..]</p>
</div>
<div class="section" id="description">
<h4><span class="section-number">10.1.2. </span>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="examples">
<h4><span class="section-number">10.1.3. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat example.csv
x,y
1,10
2,20
$ ap.cawk &#39;{print $x + $y}&#39; example.csv
11
22
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ap.cawk &#39;NR == 2 {print HEADER} {print $x + $y}&#39; q
x,y
11
22
33
</pre></div>
</div>
</div>
<div class="section" id="source">
<h4><span class="section-number">10.1.4. </span>Source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<span id="document-lib1/ap-format"></span><div class="section" id="format">
<h3><span class="section-number">10.2. </span>Format<a class="headerlink" href="#format" title="Permalink to this headline">¶</a></h3>
<div class="section" id="synopsis">
<h4><span class="section-number">10.2.1. </span>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h4>
<p>ap.format [-y]</p>
<p>runs clang-format for all C/C++ files found recursively from current directory.</p>
<dl class="option-list">
<dt><kbd><span class="option">-y</span></kbd></dt>
<dd><p>Force ‘yes’ for all questions</p>
</dd>
</dl>
</div>
<div class="section" id="configuration">
<h4><span class="section-number">10.2.2. </span>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h4>
<p>The configuration is based on Google code style with modifications.</p>
<p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/.clang-format">.clang-format</a></p>
</div>
<div class="section" id="source">
<h4><span class="section-number">10.2.3. </span>Source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/deploy/scripts/format">deploy/scripts/format</a></p>
</div>
</div>
<span id="document-lib1/ap-hist"></span><div class="section" id="histogram">
<h3><span class="section-number">10.3. </span>Histogram<a class="headerlink" href="#histogram" title="Permalink to this headline">¶</a></h3>
<div class="section" id="synopsis">
<h4><span class="section-number">10.3.1. </span>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h4>
<p>ap.hist [–density|–cumulative] [–bins BINS] [–range L R]</p>
<p>print histogram of STDIN as columns [center,density,left,right]</p>
</div>
<div class="section" id="examples">
<h4><span class="section-number">10.3.2. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="mi">10</span> <span class="o">|</span> <span class="n">ap</span><span class="o">.</span><span class="n">hist</span> <span class="o">--</span><span class="n">density</span>
<span class="n">seq</span> <span class="mi">10</span> <span class="o">|</span> <span class="n">ap</span><span class="o">.</span><span class="n">hist</span> <span class="o">--</span><span class="n">cumulative</span>
</pre></div>
</div>
</div>
<div class="section" id="source">
<h4><span class="section-number">10.3.3. </span>Source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/deploy/scripts/hist">deploy/scripts/hist</a></p>
</div>
</div>
</div>
</div>
<span id="document-lib3/index"></span><div class="section" id="library">
<h2><span class="section-number">11. </span>Library<a class="headerlink" href="#library" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-lib3/vof"></span><div class="section" id="vof-advection">
<h3><span class="section-number">11.1. </span>VOF advection<a class="headerlink" href="#vof-advection" title="Permalink to this headline">¶</a></h3>
<div class="section" id="synopsis">
<h4><span class="section-number">11.1.1. </span>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h4>
<p>Volume-of-fluid advection solver with PLIC reconstruction.</p>
</div>
<div class="section" id="parameters">
<h4><span class="section-number">11.1.2. </span>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">VofPar</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">Scal</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">M</span><span class="o">::</span><span class="n">Scal</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">Vect</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">M</span><span class="o">::</span><span class="n">Vect</span><span class="p">;</span>

  <span class="kt">size_t</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// dimension (dim=2 assumes zero velocity in z)</span>
  <span class="n">Scal</span> <span class="n">clipth</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">;</span> <span class="c1">// vf clipping threshold</span>
  <span class="n">Scal</span> <span class="n">filterth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// orphan filtering threshold</span>
  <span class="kt">bool</span> <span class="n">recolor</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// run connected component labeling on every step</span>
  <span class="kt">bool</span> <span class="n">recolor_unionfind</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// use union-find algorithm</span>
  <span class="kt">bool</span> <span class="n">recolor_reduce</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// reduce set of colors to integers</span>
  <span class="kt">bool</span> <span class="n">recolor_grid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// use grid heuristic</span>
  <span class="n">Scal</span> <span class="n">clfixed</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span> <span class="c1">// if &gt;= 0, value for color at point clfixed_x</span>
  <span class="n">Vect</span> <span class="n">clfixed_x</span> <span class="o">=</span> <span class="n">Vect</span><span class="p">(</span><span class="mf">1e10</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">cloverride</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// XXX adhoc if clear1&lt;1, override color with 0</span>
  <span class="kt">bool</span> <span class="n">sharpen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">Scal</span> <span class="n">sharpen_cfl</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">layers</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">Scal</span> <span class="n">avgnorm0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// original normal with sum(u)&lt;avgnorm0</span>
  <span class="n">Scal</span> <span class="n">avgnorm1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// overriden normal with sum(u)&gt;=acgnorm1</span>
  <span class="n">Scal</span> <span class="n">coalth</span> <span class="o">=</span> <span class="mf">1e10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">verb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">bcc_reflectpoly</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// reflection for DumpPolyMarch</span>
  <span class="n">Scal</span> <span class="n">dumppolymarch_fill</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span> <span class="c1">// fill cells outside</span>
  <span class="kt">bool</span> <span class="n">vtkbin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">vtkmerge</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">vtkpoly</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// dump vtk polygins instead of lines</span>
  <span class="n">Scal</span> <span class="n">vtkiso</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="k">enum</span> <span class="k">class</span> <span class="nc">Scheme</span> <span class="p">{</span> <span class="n">plain</span><span class="p">,</span> <span class="n">aulisa</span><span class="p">,</span> <span class="n">weymouth</span> <span class="p">};</span>
  <span class="n">Scheme</span> <span class="n">scheme</span> <span class="o">=</span> <span class="n">Scheme</span><span class="o">::</span><span class="n">weymouth</span><span class="p">;</span>
  <span class="c1">// Enables extrapolation to halo or cut cells,</span>
  <span class="c1">// required for the contact angle model.</span>
  <span class="c1">// Extrapolate volume fraction to excluded cells before computing normals</span>
  <span class="c1">// Extrapolate volume fraction, plane constant and normals to cut cells</span>
  <span class="c1">// after the advection step.</span>
  <span class="c1">// If embedded boundaries are enabled, supports only periodic condtitions.</span>
  <span class="kt">bool</span> <span class="n">extrapolate_boundaries</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">Labeling</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;*</span> <span class="n">labeling</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// Pointer to implementation of</span>
                                   <span class="c1">// connected component labeling.</span>
                                   <span class="c1">// Defaults to Recolor().</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="source">
<h4><span class="section-number">11.1.3. </span>Source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line"><a class="reference external" href="https://github.com/cselab/aphros/blob/master/src/solver/vof.h">src/solver/vof.h</a></div>
<div class="line"><a class="reference external" href="https://github.com/cselab/aphros/blob/master/src/solver/vof.cpp">src/solver/vof.cpp</a></div>
<div class="line"><a class="reference external" href="https://github.com/cselab/aphros/blob/master/src/solver/vof.ipp">src/solver/vof.ipp</a></div>
</div>
</div>
<div class="section" id="example">
<h4><span class="section-number">11.1.4. </span>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/100_advection/main.cpp">examples/100_advection/main.cpp</a></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Created by Petr Karnakov on 24.12.2019</span>
<span class="c1">// Copyright 2019 ETH Zurich</span>

<span class="cp">#undef NDEBUG</span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;distr/distrbasic.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;solver/vof.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">M</span> <span class="o">=</span> <span class="n">MeshCartesian</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Scal</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">M</span><span class="o">::</span><span class="n">Scal</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Vect</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">M</span><span class="o">::</span><span class="n">Vect</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Run</span><span class="p">(</span><span class="n">M</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">Vars</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">sem</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">GetSem</span><span class="p">();</span>

  <span class="k">struct</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Vof</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span> <span class="n">as</span><span class="p">;</span> <span class="c1">// advection solver</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fc_src</span><span class="p">;</span> <span class="c1">// volume source</span>
    <span class="n">FieldEmbed</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fe_flux</span><span class="p">;</span> <span class="c1">// volume flux</span>
    <span class="n">MapEmbed</span><span class="o">&lt;</span><span class="n">BCondAdvection</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;&gt;</span> <span class="n">mf_cond</span><span class="p">;</span> <span class="c1">// face conditions</span>
  <span class="p">}</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>

  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">as</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">as</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Scal</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Vect</span> <span class="n">vel</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">Scal</span> <span class="n">cfl</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">fc_src</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fc_src</span><span class="p">;</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">fe_flux</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fe_flux</span><span class="p">;</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">mf_cond</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mf_cond</span><span class="p">;</span>

    <span class="n">fc_src</span><span class="p">.</span><span class="n">Reinit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">fe_flux</span><span class="p">.</span><span class="n">Reinit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">m</span><span class="p">.</span><span class="n">Faces</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">fe_flux</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">vel</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">GetSurface</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fccl</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// initial color</span>
    <span class="n">FieldCell</span><span class="o">&lt;</span><span class="n">Scal</span><span class="o">&gt;</span> <span class="n">fcu</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// initial volume fraction</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">m</span><span class="p">.</span><span class="n">Cells</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">fcu</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">GetCenter</span><span class="p">(</span><span class="n">c</span><span class="p">).</span><span class="n">dist</span><span class="p">(</span><span class="n">Vect</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">Scal</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">cfl</span> <span class="o">*</span> <span class="n">m</span><span class="p">.</span><span class="n">GetCellSize</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">vel</span><span class="p">.</span><span class="n">norm</span><span class="p">();</span>
    <span class="k">typename</span> <span class="nc">Vof</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">Par</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">as</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">Vof</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fcu</span><span class="p">,</span> <span class="n">fccl</span><span class="p">,</span> <span class="n">mf_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fe_flux</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_src</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">sem</span><span class="p">.</span><span class="n">LoopBegin</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">.</span><span class="n">Nested</span><span class="p">(</span><span class="s">&quot;start&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">StartStep</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">.</span><span class="n">Nested</span><span class="p">(</span><span class="s">&quot;iter&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">MakeIteration</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">.</span><span class="n">Nested</span><span class="p">(</span><span class="s">&quot;finish&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">as</span><span class="o">-&gt;</span><span class="n">FinishStep</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">(</span><span class="s">&quot;checkloop&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">GetTime</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">tmax</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sem</span><span class="p">.</span><span class="n">LoopBreak</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">(</span><span class="s">&quot;dump&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">Dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as</span><span class="o">-&gt;</span><span class="n">GetField</span><span class="p">(),</span> <span class="s">&quot;u&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sem</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="n">sem</span><span class="p">.</span><span class="n">LoopEnd</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">conf</span> <span class="o">=</span> <span class="sa">R</span><span class="s">&quot;</span><span class="dl">EOF(</span><span class="s"></span>
<span class="s">set int bx 1</span>
<span class="s">set int by 1</span>
<span class="s">set int bz 1</span>

<span class="s">set int bsx 16</span>
<span class="s">set int bsy 16</span>
<span class="s">set int bsz 16</span>

<span class="s">set int px 1</span>
<span class="s">set int py 1</span>
<span class="s">set int pz 1</span>
<span class="dl">)EOF</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="n">MpiWrapper</span> <span class="n">mpi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">RunMpiBasicString</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mpi</span><span class="p">,</span> <span class="n">Run</span><span class="p">,</span> <span class="n">conf</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<span id="document-log/index"></span><div class="section" id="log">
<h2><span class="section-number">12. </span>Log<a class="headerlink" href="#log" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-log/log"></span><div class="section" id="surface-tension-as-gradient">
<h3><span class="section-number">12.1. </span>Surface tension as gradient<a class="headerlink" href="#surface-tension-as-gradient" title="Permalink to this headline">¶</a></h3>
<p>2018-08-30 22:08:47</p>
<p><strong>Goal</strong>: zero integral of force</p>
<p><strong>What</strong>: surface tension as <img class="math" src="_images/math/b0b3a9ce06f121dd73cc41968b3854443510f587.svg" alt="\nabla (\kappa \alpha)" style="vertical-align: -5px"/> on faces,
curvature in cells copied from neighbour faces if nan.</p>
<p><strong>Result</strong>: instability for test of single drop equilibrium,</p>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log01_grad_ka">doc/sphinx/src/log/log01_grad_ka</a></p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log01_grad_ka/grad_ka.mp4">doc/sphinx/src/log/log01_grad_ka/grad_ka.mp4</a>: surface tension as
<img class="math" src="_images/math/597b1cd61a59dbdee4a587864615e81b05cee82f.svg" alt="\nabla (\kappa * \alpha)" style="vertical-align: -5px"/></p></li>
<li><p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log01_grad_ka/k_grad_a.mp4">doc/sphinx/src/log/log01_grad_ka/k_grad_a.mp4</a>: surface tension as
<img class="math" src="_images/math/afcd172b559e52beaecb8144e7cd95fe7cf80183.svg" alt="\kappa \nabla \alpha" style="vertical-align: 0px"/></p></li>
<li><p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log01_grad_ka/k_grad_a_kmean.mp4">doc/sphinx/src/log/log01_grad_ka/k_grad_a_kmean.mp4</a>: mean
curvature on face if both cells contain interface</p></li>
</ul>
</div>
<div class="section" id="particle-normal-displacement">
<h3><span class="section-number">12.2. </span>Particle normal displacement<a class="headerlink" href="#particle-normal-displacement" title="Permalink to this headline">¶</a></h3>
<p>2018-09-02 09:41:49</p>
<p><strong>Goal</strong>: reduce spurious flow and deformation for single drop
equilibrium</p>
<p><strong>What</strong>: particle strings without normal displacement, position of
central particle fixed at the interface line center</p>
<p><strong>Result</strong>: deformation of the interface greatly reduced, probably due
to stronger coupling or penalization of deformed interfaces</p>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log02_dn">doc/sphinx/src/log/log02_dn</a></p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log02_dn/dn0.mp4">doc/sphinx/src/log/log02_dn/dn0.mp4</a>: without normal displacement</p></li>
<li><p><a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log02_dn/dn1.mp4">doc/sphinx/src/log/log02_dn/dn1.mp4</a>: with normal displacement</p></li>
</ul>
</div>
<div class="section" id="march-native">
<h3><span class="section-number">12.3. </span><code class="docutils literal notranslate"><span class="pre">march=native</span></code><a class="headerlink" href="#march-native" title="Permalink to this headline">¶</a></h3>
<p>2018-09-09 11:59:47</p>
<p><strong>Goal</strong>: use automatic vectorization and specific optimizations</p>
<p><strong>What</strong>: add <code class="docutils literal notranslate"><span class="pre">-march=native</span></code> to <code class="docutils literal notranslate"><span class="pre">CMAKE_C_FLAGS</span></code> and
<code class="docutils literal notranslate"><span class="pre">CMAKE_CXX_FLAGS</span></code></p>
<p><strong>Result</strong>: slight improvement of performance (3.60 vs 3.76 s for
<code class="docutils literal notranslate"><span class="pre">confdiff:01:assemble</span></code>) with 64 cores on Euler</p>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log03_native">doc/sphinx/src/log/log03_native</a>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">out_std</span></code>: standard flags</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">out_native</span></code>: <code class="docutils literal notranslate"><span class="pre">-march=native</span></code></p></li>
</ul>
</div>
<div class="section" id="max-iter">
<h3><span class="section-number">12.4. </span><code class="docutils literal notranslate"><span class="pre">max_iter</span></code><a class="headerlink" href="#max-iter" title="Permalink to this headline">¶</a></h3>
<p>2018-09-12 14:03:27</p>
<p><strong>Goal</strong>: choose optimal number of iterations <code class="docutils literal notranslate"><span class="pre">max_iter</span></code></p>
<p><strong>What</strong>: Taylor-Green with bubbles (<code class="docutils literal notranslate"><span class="pre">sim06</span></code>) with
<code class="docutils literal notranslate"><span class="pre">max_iter</span></code>=1,2,3,4,5 and <code class="docutils literal notranslate"><span class="pre">convsc</span></code>=<code class="docutils literal notranslate"><span class="pre">cd</span></code>,<code class="docutils literal notranslate"><span class="pre">quick</span></code>.</p>
<p><strong>Result</strong></p>
<ul class="simple">
<li><p>qualitatively different trajectories for <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>=1,2;</p></li>
<li><p>convergence at <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>=4</p></li>
<li><p>no major difference between <code class="docutils literal notranslate"><span class="pre">cd</span></code> and <code class="docutils literal notranslate"><span class="pre">quick</span></code>,</p></li>
<li><p>no difference between <code class="docutils literal notranslate"><span class="pre">simpler</span></code>=0 and 1</p></li>
</ul>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log04_maxit">doc/sphinx/src/log/log04_maxit</a></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kedr.pdf</span></code>: kinetic energy dissipation rate</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">traj.pdf</span></code>: x-component of trajectory of bubble 2</p></li>
</ul>
</div>
<div class="section" id="number-of-particles-and-strings">
<h3><span class="section-number">12.5. </span>Number of particles and strings<a class="headerlink" href="#number-of-particles-and-strings" title="Permalink to this headline">¶</a></h3>
<p><strong>Goal</strong>: check the influence of the <code class="docutils literal notranslate"><span class="pre">part_np</span></code> and <code class="docutils literal notranslate"><span class="pre">part_ns</span></code> in
curvature estimator</p>
<p><strong>What</strong>: Free-field coalescence of bubbles based on <code class="docutils literal notranslate"><span class="pre">sim04_univel</span></code></p>
<p><strong>Result</strong></p>
<ul class="simple">
<li><p>slight differences in shapes comparing <code class="docutils literal notranslate"><span class="pre">np=5,0</span></code> and <code class="docutils literal notranslate"><span class="pre">ns=2,3</span></code></p></li>
</ul>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log05_coalnp">doc/sphinx/src/log/log05_coalnp</a></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gen1_ns3_np5</span></code>: configuration</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nx064_ns?_np?.png</span></code>: shapes at <code class="docutils literal notranslate"><span class="pre">t=0.466</span></code> with <code class="docutils literal notranslate"><span class="pre">nx=64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nx128_ns2_np9.png</span></code>: shapes at <code class="docutils literal notranslate"><span class="pre">t=0.466</span></code> with <code class="docutils literal notranslate"><span class="pre">nx=128</span></code></p></li>
</ul>
</div>
<div class="section" id="number-of-iterations-for-coalescence">
<h3><span class="section-number">12.6. </span>Number of iterations for coalescence<a class="headerlink" href="#number-of-iterations-for-coalescence" title="Permalink to this headline">¶</a></h3>
<p><strong>Goal</strong>: check the influence of the <code class="docutils literal notranslate"><span class="pre">min_iter</span></code> and <code class="docutils literal notranslate"><span class="pre">tol</span></code> on bubble
coalescence</p>
<p><strong>What</strong>: Free-field coalescence of bubbles based on
<code class="docutils literal notranslate"><span class="pre">sim04_univel/case/partstrcoal</span></code></p>
<p><strong>Result</strong></p>
<ul class="simple">
<li><p>negligible difference in trajectories between default and
<code class="docutils literal notranslate"><span class="pre">min_iter=10</span></code></p></li>
</ul>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log06_coaliter">doc/sphinx/src/log/log06_coaliter</a></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nx*iter*</span></code>: configuration, data, movie</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a.gnu</span></code>: gnuplot script</p></li>
</ul>
</div>
<div class="section" id="relaxation-parameters">
<h3><span class="section-number">12.7. </span>Relaxation parameters<a class="headerlink" href="#relaxation-parameters" title="Permalink to this headline">¶</a></h3>
<p>2019-03-21 22:48:56</p>
<p><strong>Goal</strong>: check the influence of <code class="docutils literal notranslate"><span class="pre">vrelax</span></code> and <code class="docutils literal notranslate"><span class="pre">prelax</span></code> on bubble
coalescence</p>
<p><strong>What</strong>: Near-wall coalescence of bubbles with
<code class="docutils literal notranslate"><span class="pre">vrelax=0.8,prelax=0.8</span></code> and <code class="docutils literal notranslate"><span class="pre">vrelax=0.9,prelax=1</span></code></p>
<p><strong>Result</strong></p>
<ul class="simple">
<li><p>spurious oscillations in the pressure field (<code class="docutils literal notranslate"><span class="pre">wforce</span></code>) with
<code class="docutils literal notranslate"><span class="pre">vrelax=0.9</span></code> after the bubble detachment</p></li>
<li><p>no effect on x- and y-trajectories, slower rising in z after
detachment</p></li>
<li><p>changed default parameters for <code class="docutils literal notranslate"><span class="pre">sim04</span></code> to <code class="docutils literal notranslate"><span class="pre">prelax=0.8</span></code>,
<code class="docutils literal notranslate"><span class="pre">vrelax=0.8</span></code> and <code class="docutils literal notranslate"><span class="pre">min_iter=4</span></code></p></li>
</ul>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log07_vrelax">doc/sphinx/src/log/log07_vrelax</a></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gen1</span></code>: generator of parameters for <code class="docutils literal notranslate"><span class="pre">sim04/gen</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wforce</span></code>: force acting on <code class="docutils literal notranslate"><span class="pre">z=0</span></code> and <code class="docutils literal notranslate"><span class="pre">z=1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">out</span></code>, <code class="docutils literal notranslate"><span class="pre">stat.dat</span></code>: log and statistics</p></li>
</ul>
</div>
<div class="section" id="reduced-usage-of-getcenter">
<h3><span class="section-number">12.8. </span>Reduced usage of <code class="docutils literal notranslate"><span class="pre">GetCenter</span></code><a class="headerlink" href="#reduced-usage-of-getcenter" title="Permalink to this headline">¶</a></h3>
<p>2019-04-27 01:19:03</p>
<p><strong>Goal</strong>: Performance improvement.</p>
<p><strong>What</strong>: Reduced usage of <code class="docutils literal notranslate"><span class="pre">GetCenter</span></code> and <code class="docutils literal notranslate"><span class="pre">GetVectToCell</span></code>. Test of
the Taylor-Green vortex with bubbles.</p>
<p><strong>Result</strong>: Speedup of 15%.</p>
<p><strong>Data</strong> <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log08_getcenter">doc/sphinx/src/log/log08_getcenter</a></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tg</span></code>: setup</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tg0_*</span></code>: timings before</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tg1_*</span></code>: timings after</p></li>
</ul>
</div>
<div class="section" id="debug-linear-solver-with-convertlscompact">
<h3><span class="section-number">12.9. </span>Debug linear solver with <code class="docutils literal notranslate"><span class="pre">ConvertLsCompact</span></code><a class="headerlink" href="#debug-linear-solver-with-convertlscompact" title="Permalink to this headline">¶</a></h3>
<p>2019-08-15 10:04:39</p>
<p><strong>Goal</strong>: Fix <code class="docutils literal notranslate"><span class="pre">sim12_ringgauss</span></code> after reimplementing <code class="docutils literal notranslate"><span class="pre">simple.ipp</span></code>
with <code class="docutils literal notranslate"><span class="pre">ConvertLsCompact</span></code> in <code class="docutils literal notranslate"><span class="pre">48fa3cf0</span></code>. Iterations for pressure
correction diverged.</p>
<p><strong>What</strong>: Bisection between <code class="docutils literal notranslate"><span class="pre">1ffd55c5</span></code> from <code class="docutils literal notranslate"><span class="pre">Jan</span> <span class="pre">12</span> <span class="pre">2019</span></code> and
<code class="docutils literal notranslate"><span class="pre">9cb90989</span></code> from <code class="docutils literal notranslate"><span class="pre">Aug</span> <span class="pre">14</span> <span class="pre">2019</span></code>. Complication from another bug in
<code class="docutils literal notranslate"><span class="pre">InitVort()</span></code> which attempted to use uninitialized <code class="docutils literal notranslate"><span class="pre">fs_</span></code> in
<code class="docutils literal notranslate"><span class="pre">hydro.h</span></code> (fixed by <code class="docutils literal notranslate"><span class="pre">patch</span></code>).</p>
<p><strong>Result</strong>: Found the problem by printing the coefficients of the linear
system before and after <code class="docutils literal notranslate"><span class="pre">ConvertLs()</span></code> or <code class="docutils literal notranslate"><span class="pre">ConvertLsCompact()</span></code>. The
problem appeared from changing the order of stencil cells. In <code class="docutils literal notranslate"><span class="pre">sim12</span></code>,
the symmetric linear solver is called twice: for initialization of
vorticity and for pressure correction. Then Hypre is apparently
initialized only once and that instance is used for both cases which
leads to the wrong order of coefficients.</p>
<p><strong>Data</strong>: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log09_debug_linear">doc/sphinx/src/log/log09_debug_linear</a></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">patch</span></code>: fix for <code class="docutils literal notranslate"><span class="pre">InitVort()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code>: tool to apply patch and rebuild</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">simple_{bad,good}.ipp</span></code>: two versions of <code class="docutils literal notranslate"><span class="pre">simple.ipp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min</span></code>: minimal simulation setup</p></li>
</ul>
</div>
<div class="section" id="registered-modules-in-ubuntu">
<h3><span class="section-number">12.10. </span>Registered modules in Ubuntu<a class="headerlink" href="#registered-modules-in-ubuntu" title="Permalink to this headline">¶</a></h3>
<p>2020-06-03 11:34:54</p>
<p>Ubuntu has <code class="docutils literal notranslate"><span class="pre">--as-needed</span></code> by default (seen from <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">-dumpspecs</span></code>)
which makes the linker ignore unused libraries
and, in particular, the implementations of modules (e.g. <code class="docutils literal notranslate"><span class="pre">init_contang.so</span></code>).</p>
</div>
<div class="section" id="vtk-merge-comparison-of-floats-with-tolerance">
<h3><span class="section-number">12.11. </span>VTK merge, comparison of floats with tolerance<a class="headerlink" href="#vtk-merge-comparison-of-floats-with-tolerance" title="Permalink to this headline">¶</a></h3>
<p>2020-06-13 21:56:35</p>
<p><code class="docutils literal notranslate"><span class="pre">ConvertMerge</span></code> in <code class="docutils literal notranslate"><span class="pre">dump/vtk.h</span></code> mapped each <code class="docutils literal notranslate"><span class="pre">Vect</span></code> to a hash
and used the hash to merge closely located points together
(up to tolerance <code class="docutils literal notranslate"><span class="pre">tol</span></code>).
This effectively split the space of <code class="docutils literal notranslate"><span class="pre">Vect</span></code> to partitions.
However, if two points are located close to the boundary between
two partitions, they can be arbitrarily close but have
different hash values.</p>
<p>The solution was to check compare against the hash
of neighboring points (from vertices of a cube)
when looking for an existing hash.</p>
<p>Minimal example that gave vertices of rank 1: <a class="reference external" href="https://github.com/cselab/aphros/blob/master/doc/sphinx/src/log/log10_vtkmerge">doc/sphinx/src/log/log10_vtkmerge</a>.</p>
<p>The opposite problem: hash collisions of distant points.
Example is in <code class="docutils literal notranslate"><span class="pre">log10_vtkmerge/hash_collision</span></code>.
To fix, changed the map from <code class="docutils literal notranslate"><span class="pre">hash-&gt;index</span></code> to <code class="docutils literal notranslate"><span class="pre">Vect-&gt;index</span></code>
(ensures exact comparison of points)
and introduced <code class="docutils literal notranslate"><span class="pre">canonical(x)</span></code> to get a single point from the cell of
size <code class="docutils literal notranslate"><span class="pre">tol</span></code>.</p>
<a class="reference internal image-reference" href="_images/vtkmerge.svg"><img alt="_images/vtkmerge.svg" class="align-center" src="_images/vtkmerge.svg" width="300" /></a>
</div>
<div class="section" id="explicit-part-of-viscous-stress">
<h3><span class="section-number">12.12. </span>Explicit part of viscous stress<a class="headerlink" href="#explicit-part-of-viscous-stress" title="Permalink to this headline">¶</a></h3>
<p>2021-06-11 15:32:27</p>
<p>The viscous stress tensor has the form <img class="math" src="_images/math/1b6a3ce382aa40ed3b45a00b4c8d5a0cf8408dec.svg" alt="\mu(\nabla\mathbf{u} +\nabla\mathbf{u}^T)" style="vertical-align: -5px"/>.
Parameter <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">explviscous</span></code> controls whether the second term is included in
the discretization. Setting <code class="docutils literal notranslate"><span class="pre">explviscous=0</span></code> changes the approximated tensor
to <img class="math" src="_images/math/c3010be01decb691a8b7377d167b5541ed82c2a0.svg" alt="\mu\nabla\mathbf{u}" style="vertical-align: -4px"/>.
This omitted term <img class="math" src="_images/math/9b500f1188530918bbf853f4c57608816db13a8a.svg" alt="\mu\nabla\mathbf{u}^T" style="vertical-align: -4px"/> is significant if the dynamic viscosity is non-uniform.</p>
<p>The following test case of a rising bubble
(based on <a class="reference external" href="http://basilisk.fr/src/test/rising.c">http://basilisk.fr/src/test/rising.c</a>) shows a small difference.
See full example in <a class="reference external" href="https://github.com/cselab/aphros/blob/master/examples/208_rising">examples/208_rising</a>.</p>
<table class="docutils align-center" id="t-bubble">
<caption><span class="caption-number">Table 12.1 </span><span class="caption-text">Bubble shapes at <img class="math" src="_images/math/428f45c13544955acca2ceb798d369dc44aaa06a.svg" alt="t=3" style="vertical-align: 0px"/></span><a class="headerlink" href="#t-bubble" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_images/explviscous.png"><img alt="log11" src="_images/explviscous.png" style="width: 300px;" /></a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<span id="document-styleguide"></span><div class="section" id="contributing">
<h2><span class="section-number">13. </span>Contributing<a class="headerlink" href="#contributing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="style-guide">
<h3><span class="section-number">13.1. </span>Style guide<a class="headerlink" href="#style-guide" title="Permalink to this headline">¶</a></h3>
<p>Use <a class="reference external" href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a>.</p>
<p>Loop indices:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> - generic</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">c</span></code> - IdxCell</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> - IdxFace</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> - MIdx</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> - direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">d</span></code> - index <code class="docutils literal notranslate"><span class="pre">0..dim-1</span></code></p></li>
</ul>
</div>
</div>
<span id="document-references"></span><div class="section" id="bibliography">
<h2><span class="section-number">14. </span>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
</div>
<p id="id1"><dl class="citation">
<dt class="label" id="id2"><span class="brackets">1</span></dt>
<dd><p>Gabriel D Weymouth and Dick K-P Yue. Conservative volume-of-fluid method for free-surface simulations on cartesian-grids. <em>Journal of Computational Physics</em>, 229(8):2853–2865, 2010.</p>
</dd>
<dt class="label" id="id3"><span class="brackets">2</span></dt>
<dd><p>Ann S Almgren, John B Bell, Phillip Colella, and Tyler Marthaler. A cartesian grid projection method for the incompressible euler equations in complex geometries. <em>SIAM Journal on Scientific Computing</em>, 18(5):1289–1309, 1997.</p>
</dd>
<dt class="label" id="id4"><span class="brackets">3</span></dt>
<dd><p>S Mohammad H Hashemi, Petr Karnakov, Pooria Hadikhani, Enrico Chinello, Sergey Litvinov, Christophe Moser, Petros Koumoutsakos, and Demetri Psaltis. A versatile and membrane-less electrochemical reactor for the electrolysis of water and brine. <em>Energy &amp; Environmental Science</em>, 12(5):1592–1604, 2019.</p>
</dd>
<dt class="label" id="id5"><span class="brackets">4</span></dt>
<dd><p>Petr Karnakov, Fabian Wermelinger, Michail Chatzimanolakis, Sergey Litvinov, and Petros Koumoutsakos. A high performance computing framework for multiphase, turbulent flows on structured grids. In <em>Proceedings of the Platform for Advanced Scientific Computing Conference</em>, 1–9. 2019.</p>
</dd>
<dt class="label" id="id6"><span class="brackets">5</span></dt>
<dd><p>Petr Karnakov, Sergey Litvinov, and Petros Koumoutsakos. A hybrid particle volume-of-fluid method for curvature estimation in multiphase flows. <em>International Journal of Multiphase Flow</em>, 125:103209, 2020.</p>
</dd>
<dt class="label" id="id7"><span class="brackets">6</span></dt>
<dd><p>Zhong Yi Wan, Petr Karnakov, Petros Koumoutsakos, and Themistoklis P Sapsis. Bubbles in turbulent flows: data-driven, kinematic models with history terms. <em>International Journal of Multiphase Flow</em>, 129:103286, 2020.</p>
</dd>
<dt class="label" id="id8"><span class="brackets">7</span></dt>
<dd><p>Petr Karnakov, Sergey Litvinov, Jean M Favre, and Petros Koumoutsakos. Breaking waves: to foam or not to foam? <em>Physical Review Fluids</em>, 5(11):110503, 2020.</p>
</dd>
<dt class="label" id="id9"><span class="brackets">8</span></dt>
<dd><p>Petr Karnakov, Fabian Wermelinger, Sergey Litvinov, and Petros Koumoutsakos. Aphros: high performance software for multiphase flows with large scale bubble and drop clusters. In <em>Proceedings of the Platform for Advanced Scientific Computing Conference</em>, 1–10. 2020.</p>
</dd>
<dt class="label" id="id10"><span class="brackets">9</span></dt>
<dd><p>Petr Karnakov, Sergey Litvinov, and Petros Koumoutsakos. Computing foaming flows across scales: from breaking waves to microfluidics. <em>arXiv preprint arXiv:2103.01513</em>, 2021.</p>
</dd>
</dl>
</p>
</div>
</div>


  </body>
</html>
