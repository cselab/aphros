#pragma once

#include <mpi.h>
#include <array>
#include <cassert>
#include <chrono>
#include <cstdio>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <memory>
#include <random>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <thread>

#include "debug/isnan.h"
#include "dump/dumper.h"
#include "dump/output.h"
#include "func/init_cl.h"
#include "func/init_sig.h"
#include "func/init_u.h"
#include "geom/mesh.h"
#include "kernelmesh.h"
#include "parse/curv.h"
#include "parse/parser.h"
#include "parse/proj.h"
#include "parse/simple.h"
#include "parse/tvd.h"
#include "parse/util.h"
#include "parse/vars.h"
#include "parse/vof.h"
#include "solver/advection.h"
#include "solver/curv.h"
#include "solver/multi.h"
#include "solver/normal.h"
#include "solver/pois.h"
#include "solver/proj.h"
#include "solver/reconst.h"
#include "solver/simple.h"
#include "solver/solver.h"
#include "solver/sphavg.h"
#include "solver/tvd.h"
#include "solver/vof.h"
#include "solver/vofm.h"
#include "util/convdiff.h"
#include "util/events.h"
#include "util/hydro.h"
#include "young/young.h"

class GPar {};

// Smoothens fieldcell with node-based averaging.
// fc: fieldcell [s]
// rep: number of iterations
// Output:
// fc: smooth field [s]
template <class T, class M>
void SmoothenNode(FieldCell<T>& fc, M& m, size_t rep) {
  auto sem = m.GetSem("smoothen");
  for (size_t i = 0; i < rep; ++i) {
    if (sem()) {
      using Scal = typename M::Scal;
      // generated by gen/smooth.py
      std::array<Scal, 27> a = {
          0.015625, 0.03125,  0.015625, 0.03125,  0.0625,   0.03125, 0.015625,
          0.03125,  0.015625, 0.03125,  0.0625,   0.03125,  0.0625,  0.125,
          0.0625,   0.03125,  0.0625,   0.03125,  0.015625, 0.03125, 0.015625,
          0.03125,  0.0625,   0.03125,  0.015625, 0.03125,  0.015625};

      using MIdx = typename M::MIdx;
      auto& bc = m.GetIndexCells();
      GBlock<IdxCell, M::dim> bo(MIdx(-1), MIdx(3));
      auto fcm = fc;
      for (auto c : m.Cells()) {
        MIdx w = bc.GetMIdx(c);
        T u = 0;
        size_t i = 0;
        for (MIdx wo : bo) {
          IdxCell cn = bc.GetIdx(w + wo);
          u += fcm[cn] * a[i++];
        }
        fc[c] = u;
      }
      m.Comm(&fc);
    }
  }
}

template <class M_>
class Hydro : public KernelMeshPar<M_, GPar> {
 public:
  using P = KernelMeshPar<M_, GPar>; // parent
  using M = M_;
  using Scal = typename M::Scal;
  using Vect = typename M::Vect;
  using MIdx = typename M::MIdx;
  using Sem = typename M::Sem;
  using Par = GPar;
  template <class T>
  using Multi = solver::Multi<T>;
  static constexpr size_t dim = M::dim;

  Hydro(Vars&, const MyBlockInfo&, Par&);
  void Run() override;
  M& GetMesh() {
    return m;
  }

 protected:
  using P::bi_;
  using P::m;
  using P::var;

 private:
  void Init();
  void InitFluid();
  void InitAdvection();
  void InitStat();
  void InitVort();
  // zero-gradient bc vect
  MapCondFace GetBcVz() const;
  // zero-gradient bc scal
  MapCondFace GetBcSz() const;
  void DumpFields();
  void Dump();
  static void DumpTraj(
      M& m, bool dm, const Vars& var, size_t frame, Scal t,
      const GRange<size_t>& layers, const Multi<const FieldCell<Scal>*>& fcvf,
      const Multi<const FieldCell<Scal>*>& fccl,
      const Multi<const FieldCell<MIdx>*>& fcim, const FieldCell<Scal>& fcp,
      const FieldCell<Vect>& fcvel, const FieldCell<Vect>& fcvelm, Scal dt);
  // Calc rho, mu and force based on volume fraction
  void CalcMixture(const FieldCell<Scal>& vf);
  // fcvf: volume fraction on cells [a]
  // ffvfsm: smoothed volume fraction on faces [a]
  void CalcSurfaceTension(
      const FieldCell<Scal>& fcvf, const FieldFace<Scal>& ffvfsm);
  // ffst: force projections to append
  // fcu: volume fraction
  // fck: curvature
  // ffsig: surface tension coefficient
  void AppendSurfaceTension(
      FieldFace<Scal>& ffst, const FieldCell<Scal>& fcu,
      const FieldCell<Scal>& fck, const FieldFace<Scal>& ffsig);
  void AppendSurfaceTension(
      FieldFace<Scal>& ffst, const GRange<size_t>& layers,
      const solver::Multi<const FieldCell<Scal>*> fcu,
      const solver::Multi<const FieldCell<Scal>*> fccl,
      const solver::Multi<const FieldCell<Scal>*> fck,
      const FieldFace<Scal>& ffsig);
  // Clips v to given range, uses const_cast
  void Clip(const FieldCell<Scal>& v, Scal min, Scal max);
  void CalcStat();
  void CalcDt();
  void ReportStep();
  // Issue sem.LoopBreak if abort conditions met
  void CheckAbort(Sem& sem);
  void StepFluid();
  void StepAdvection();
  void StepBubgen();

  using FS = solver::FluidSolver<M>;
  using FSS = solver::Simple<M>;
  using FSP = solver::Proj<M>;
  using AST = solver::Tvd<M>; // advection TVD
  using ASV = solver::Vof<M>; // advection VOF
  using ASVM = solver::Vofm<M>; // advection VOF
  static constexpr Scal kClNone = ASVM::kClNone;
  using SA = solver::Sphavg<M>; // spherical averages

  void UpdateAdvectionPar() {
    if (auto as = dynamic_cast<AST*>(as_.get())) {
      Parse<M>(as->GetPar(), var);
    } else if (auto as = dynamic_cast<ASV*>(as_.get())) {
      Parse<M, ASV>(as->GetPar(), var);
    } else if (auto as = dynamic_cast<ASVM*>(as_.get())) {
      Parse<M, ASVM>(as->GetPar(), var);
    }
  }
  // Surface tension time step
  Scal GetStDt() {
    const Scal sig = var.Double["sigma"];
    const Scal* cflst = var.Double("cflst");
    if (cflst && sig != 0.) {
      Scal pi = M_PI;
      Scal h3 = m.GetVolume(IdxCell(0));
      Scal r1 = var.Double["rho1"];
      Scal r2 = var.Double["rho2"];
      return (*cflst) * std::sqrt(h3 * (r1 + r2) / (4. * pi * std::abs(sig)));
    }
    return std::numeric_limits<Scal>::max();
  }
  // Viscosity time step
  Scal GetVisDt() {
    const Scal rho1 = var.Double["rho1"];
    const Scal rho2 = var.Double["rho2"];
    const Scal mu1 = var.Double["mu1"];
    const Scal mu2 = var.Double["mu2"];
    const Scal nu1 = mu1 / rho1;
    const Scal nu2 = mu2 / rho2;
    const Scal num = std::max(nu1, nu2);
    const Scal* cflvis = var.Double("cflvis");
    if (cflvis && num != 0.) {
      const Scal h2 = sqr(m.GetCellSize()[0]); // XXX adhoc cubic cell
      return (*cflvis) * h2 / num;
    }
    return std::numeric_limits<Scal>::max();
  }
  YoungParam GetYoungPar() const {
    YoungParam q;
    q.rhov = var.Double["rho1"];
    q.rhou = var.Double["rho2"];
    q.muv = var.Double["mu1"];
    q.muu = var.Double["mu2"];
    q.hv = 1.;
    q.hu = 1.;
    q.gamma0 = var.Double["sigma"];
    q.gamma1 = var.Vect["sig_grad"][0];
    q.T0 = 0.;
    q.T1 = 1.;
    q.R = var.Double["youngbc_r"];
    return q;
  }
  void InitYoung() {
    young_ini(GetYoungPar());
  }
  void CalcVort() {
    auto& fcv = fs_->GetVelocity();
    fcom_ = GetVort(fcv, fs_->GetVelocityCond(), m);
    fcomm_.Reinit(m);
    for (auto c : m.Cells()) {
      fcomm_[c] = fcom_[c].norm();
    }
  }
  void CalcStrain() {
    auto& fcv = fs_->GetVelocity();
    auto& fcs = fc_strain_;

    auto ffv = solver::Interpolate(fcv, fs_->GetVelocityCond(), m);

    std::array<FieldCell<Vect>, dim> g; // g[i][c][j] is derivative du_i/dx_j
    for (size_t i = 0; i < dim; ++i) {
      g[i] = solver::Gradient(GetComponent(ffv, i), m);
    }

    fcs.Reinit(m, 0);
    int edim = var.Int["dim"];
    for (auto c : m.Cells()) {
      for (int i = 0; i < edim; ++i) {
        for (int j = 0; j < edim; ++j) {
          fcs[c] += sqr(g[i][c][j]) + g[i][c][j] * g[j][c][i];
        }
      }
      fcs[c] *= 0.5;
    }
  }
  FieldCell<Scal> GetDiv() {
    FieldCell<Scal> fc(m, 0); // result
    auto& ffv = fs_->GetVolumeFlux();

    for (auto c : m.Cells()) {
      for (auto q : m.Nci(c)) {
        IdxFace f = m.GetFace(c, q);
        fc[c] += ffv[f] * m.GetOutwardFactor(c, q);
      }
      fc[c] /= m.GetVolume(c);
    }
    return fc;
  }
  Vect GetYoungVel(Vect x) const {
    x -= Vect(0.5);
    // 0: streamwise
    // 1,2: crossstream with symmetry around 0-axis
    Scal r = Vect(0, x[1], x[2]).norm();
    Vect v(0);
    Scal vc; // vel cross
    young_fields(r, x[0], &vc, &v[0], nullptr, nullptr);
    Scal e1 = x[1] / r;
    Scal e2 = x[2] / r;
    v[1] = vc * e1;
    v[2] = vc * e2;
    return v;
  }

  GRange<size_t> layers;
  FieldCell<Scal> fc_mu_; // viscosity
  FieldCell<Scal> fc_rho_; // density
  FieldCell<Scal> fc_src_; // source of mixture volume
  FieldCell<Scal> fc_src2_; // source of second phase volume
  FieldCell<Scal> fc_srcm_; // mass source
  FieldCell<Vect> fc_force_; // force
  FieldFace<Scal> ffbp_; // balanced force projections
  FieldFace<Scal> ffk_; // curvature on faces
  MapCondFaceAdvection<Scal> mf_adv_;
  MapCondFace mf_cond_vfsm_;
  MapCondFaceFluid mf_fluid_; // fluid cond
  MapCell<std::shared_ptr<solver::CondCell>> mc_cond_;
  MapCell<std::shared_ptr<solver::CondCellFluid>> mc_velcond_;
  std::unique_ptr<solver::AdvectionSolver<M>> as_; // advection solver
  std::unique_ptr<FS> fs_; // fluid solver
  FieldCell<Scal> fc_vf_; // volume fraction used by constructor
  FieldCell<Scal> fccl_; // color used by constructor
  FieldCell<Vect> fc_vel_; // velocity used by constructor
  FieldCell<Scal> fc_smvf_; // smoothed volume fraction used by CalcMixture()
  FieldFace<Scal> ff_smvf_; // interpolated fc_smvf_
  Scal diff_; // convergence indicator
  std::pair<Scal, int> pdist_; // distance to pfixed cell

  FieldCell<Scal> fc_sig_; // surface tension sigma
  FieldFace<Scal> ff_sig_; // surface tension sigma

  FieldCell<Vect> fcvm_; // velocity field time_prev // TODO: revise

  FieldCell<Vect> fcyv_; // Young velocity
  FieldCell<Vect> fcom_; // vorticity
  FieldCell<Scal> fcomm_; // vorticity magnitude
  std::shared_ptr<solver::PoisSolver<M>> ps_; // Poisson solver for InitVort
  FieldCell<Scal> fcbc_; // boundary condition type by GetBcField()
  FieldCell<Scal> fc_strain_; // double inner product of strain rate tensor
  FieldCell<Scal> fctmp_; // temporary scalar field
  FieldCell<Scal> fctmp2_, fctmp3_, fctmp4_; // temporary scalar field
  FieldCell<Vect> fctmpv_; // temporary vector field
  FieldCell<Vect> fcvcurl_; // curl-component of velocity
  FieldCell<Scal> fcdiv_; // divergence of velocity
  Multi<FieldCell<Scal>> fck_; // curvature
  typename PartStrMeshM<M>::Par psm_par_;
  std::unique_ptr<PartStrMeshM<M>> psm_;
  bool vcurl_; // compute curl

  Scal nabort_; // number of abort requests, used by Reduce in checknan Run()

  std::function<void(FieldCell<typename M::Scal>&, const M&)> bgf_; // bubgen
  Scal bgt_ = -1.; // bubgen last time

  struct Stat {
    struct Vofm {
      Scal cells_vf; // number of cells with vf>0
      Scal cells_cl; // number of cells wih cl != kClNone
      Scal sum_vf; // sum of vf
      Scal hist; // vofm[l].hist is number of cells containing l+1
                 // cells with vf>0
    };

    Scal m1, m2; // volume
    Scal m20; // initial volume
    Scal m2d; // relative volume difference
    Vect c1, c2; // center of mass
    Vect vc1, vc2; // center of mass velocity
    Vect v1, v2; // average velocity
    Scal dtt; // temporary to reduce
    Scal dt; // dt fluid
    Scal dta; // dt advection
    size_t iter; // iter of fluid solver
    Scal dumpt = -1e10; // last dump time (rounded to nearest dtdump)
    Scal t;
    size_t step;
    size_t dumpn;
    Vect meshpos; // mesh position
    Vect meshvel; // mesh velocity
    Scal ekin, ekin1, ekin2; // kinetic energy
    Scal workst; // work by surface tension
    Vect vlm, vl2; // max-norm and l2-norm of velocity minus "vel"
    Scal pmin, pmax, pd; // pressure min,max
    Scal pavg1, pavg2; // pressure average
    Scal boxomm; // integral of vorticity magnitude over box
    Scal boxomm2; // integral of vorticity magnitude over box
    Vect vomm; // velocity weighted by vorticity
    Scal vommw; // integral of vorticity
    Scal enstr; // enstrophy
    Scal area; // interface area
    Scal dissip, dissip1, dissip2; // energy dissipation rate
    Scal edis, edis1, edis2; // dissipated energy
    std::vector<Vofm> vofm;

    std::map<std::string, Scal> mst; // map stat
    // Add scalar field for stat.
    void Add(const FieldCell<Scal>& fc, std::string name, M& m) {
      Scal min = std::numeric_limits<Scal>::max();
      Scal max = -std::numeric_limits<Scal>::max();
      Scal sum = 0.;
      for (auto c : m.Cells()) {
        Scal v = fc[c];
        min = std::min(min, v);
        max = std::max(max, v);
        sum += v * m.GetVolume(c);
      }
      m.Reduce(&(mst[name + "_mn"] = min), "min");
      m.Reduce(&(mst[name + "_mx"] = max), "max");
      m.Reduce(&(mst[name + "_sum"] = sum), "sum");
    }
    // Add component comp of vector field for stat.
    void Add(const FieldCell<Vect>& fc, size_t comp, std::string name, M& m) {
      Scal min = std::numeric_limits<Scal>::max();
      Scal max = -std::numeric_limits<Scal>::max();
      Scal sum = 0.;
      for (auto c : m.Cells()) {
        Scal v = fc[c][comp];
        min = std::min(min, v);
        max = std::max(max, v);
        sum += v * m.GetVolume(c);
      }
      m.Reduce(&(mst[name + "_mn"] = min), "min");
      m.Reduce(&(mst[name + "_mx"] = max), "max");
      m.Reduce(&(mst[name + "_sum"] = sum), "sum");
    }
    void Print(std::ostream& out) {
      std::string dl = "";
      auto fl = out.flags();
      out.precision(16);
      out << std::scientific << std::setprecision(20);
      size_t i = 0;
      for (auto it : mst) {
        if (i % 3 == 0) {
          out << "> ";
          dl = "";
        }
        out << dl << it.first << "=" << it.second;
        dl = ", ";
        ++i;
        if (i % 3 == 0) {
          out << std::endl;
        }
      }
      out.flags(fl);
    }
    void Clear() {
      mst.clear();
    }
  };
  Stat st_;
  std::shared_ptr<output::Ser> ost_; // output stat
  Dumper dumper_;
  Dumper dmptraj_; // dumper for traj
  Dumper dmptrep_; // dumper for timer report
  std::unique_ptr<Events> events_; // events from var
};

template <class M>
auto Hydro<M>::GetBcVz() const -> MapCondFace {
  // zero-derivative bc for Vect
  MapCondFace r;
  for (auto it : mf_fluid_) {
    IdxFace f = it.GetIdx();
    r[f].Set<CondFaceGradFixed<Vect>>(Vect(0), it.GetValue()->GetNci());
  }
  return r;
}

template <class M>
auto Hydro<M>::GetBcSz() const -> MapCondFace {
  // zero-derivative bc for Vect
  MapCondFace r;
  for (auto it : mf_fluid_) {
    IdxFace f = it.GetIdx();
    r[f].Set<CondFaceGradFixed<Scal>>(0., it.GetValue()->GetNci());
  }
  return r;
}

// Compute velocity fc_vel_ from vorticity stored in fc_vel_
template <class M>
void Hydro<M>::InitVort() {
  auto sem = m.GetSem("initvort");
  struct {
    MapCondFace mfcw; // velocity cond
    MapCondFace mfcwd; // velocity cond in one diretion
  } * ctx(sem);
  auto& fct = fctmp_; // temporary fields
  auto& fctv = fctmpv_;
  if (sem("initpois")) {
    m.Comm(&fc_vel_);
    fctv.Reinit(m);
    ctx->mfcw = GetVelCond(m, mf_fluid_);
  }
  for (size_t d = 0; d < M::dim; ++d) {
    std::string dn = std::to_string(d);
    if (sem("init-" + dn)) {
      ctx->mfcwd = GetScalarCond(ctx->mfcw, d, m);
      ps_ = std::make_shared<solver::PoisSolver<M>>(ctx->mfcwd, m);
      fct = GetComponent(fc_vel_, d);
      for (auto c : m.Cells()) {
        fct[c] *= -1;
      }
    }
    if (sem.Nested("solve-" + dn)) {
      ps_->Solve(fct);
    }
    if (sem("post-" + dn)) {
      SetComponent(fctv, d, ps_->GetField());
      if (m.IsRoot() && var.Int["vort_report"]) {
        std::cout << "om" << ("xyz"[d]) << ":"
                  << " res=" << m.GetResidual() << " iter=" << m.GetIter()
                  << std::endl;
      }
    }
  }
  if (sem("vel")) {
    fc_vel_ = GetVort(fctv, ctx->mfcw, m);
    m.Comm(&fc_vel_);
    fctv.Free();
    fct.Free();
  }
}

template <class M>
void Hydro<M>::InitFluid() {
  fcvm_ = fc_vel_;

  // XXX ahoc: young velocity
  if (var.Int["youngbc"]) {
    fcyv_.Reinit(m);
    InitYoung();
    for (auto c : m.Cells()) {
      Vect x = m.GetCenter(c);
      fcyv_[c] = GetYoungVel(x);
    }
  }

  std::string fs = var.String["fluid_solver"];
  if (fs == "simple") {
    auto p = std::make_shared<typename FSS::Par>();
    Parse<M>(p.get(), var);
    fs_.reset(new FSS(
        m, fc_vel_, mf_fluid_, mc_velcond_, &fc_rho_, &fc_mu_, &fc_force_,
        &ffbp_, &fc_src_, &fc_srcm_, 0., st_.dt, p));
  } else if (fs == "proj") {
    auto p = std::make_shared<typename FSP::Par>();
    Parse<M>(p.get(), var);
    fs_.reset(new FSP(
        m, fc_vel_, mf_fluid_, mc_velcond_, &fc_rho_, &fc_mu_, &fc_force_,
        &ffbp_, &fc_src_, &fc_srcm_, 0., st_.dt, p));
  } else {
    throw std::runtime_error("Unknown fluid_solver=" + fs);
  }

  fcbc_ = GetBcField(mf_fluid_, m);
}

template <class M>
void Hydro<M>::InitAdvection() {
  std::string as = var.String["advection_solver"];
  if (as == "tvd") {
    auto p = std::make_shared<typename AST::Par>();
    Parse<M>(p.get(), var);
    as_.reset(new AST(
        m, fc_vf_, mf_adv_, &fs_->GetVolumeFlux(solver::Layers::time_curr),
        &fc_src2_, 0., st_.dta, p));
  } else if (as == "vof") {
    auto p = std::make_shared<typename ASV::Par>();
    Parse<M, ASV>(p.get(), var);
    p->dmp = std::unique_ptr<Dumper>(new Dumper(var, "dump_part_"));
    as_.reset(new ASV(
        m, fc_vf_, fccl_, mf_adv_,
        &fs_->GetVolumeFlux(solver::Layers::time_curr), &fc_src2_, 0., st_.dta,
        p));
    layers = GRange<size_t>(1);
  } else if (as == "vofm") {
    auto p = std::make_shared<typename ASVM::Par>();
    Parse<M, ASVM>(p.get(), var);
    p->dmp = std::unique_ptr<Dumper>(new Dumper(var, "dump_part_"));
    auto as = new ASVM(
        m, fc_vf_, fccl_, mf_adv_,
        &fs_->GetVolumeFlux(solver::Layers::time_curr), &fc_src2_, 0., st_.dta,
        p);
    as_.reset(as);
    layers = GRange<size_t>(as->GetNumLayers());
  } else {
    throw std::runtime_error("Unknown advection_solver=" + as);
  }

  st_.vofm.resize(layers.size());
  fck_.resize(layers);
  fck_.InitAll(FieldCell<Scal>(m, GetNan<Scal>()));
  {
    typename PartStr<Scal>::Par ps;
    Parse(ps, m.GetCellSize().norminf(), var);
    Parse<M>(psm_par_, ps, var);
  }
}

template <class M>
void Hydro<M>::InitStat() {
  if (m.IsRoot()) {
    // Stat: var.Double[p] with name n
    /*
    auto on = [this](std::string n, std::string p) {
      return std::make_shared<output::OutScalFunc<Scal>>(
          n, [&,p](){ return var.Double[p]; });
    };
    */

    // Stat: *p with name n
    auto op = [](std::string n, Scal* p) {
      return std::make_shared<output::OutScalFunc<Scal>>(
          n, [p]() { return *p; });
    };

    auto& s = st_;
    output::VOut con = {
        op("t", &s.t),
        std::make_shared<output::OutScalFunc<int>>(
            "iter", [this]() { return st_.iter; }),
        op("dt", &s.dt),
        op("dta", &s.dta),
        op("diff", &diff_),
        op("m1", &s.m1),
        op("m2", &s.m2),
        op("m20", &s.m20),
        op("m2d", &s.m2d),
        op("ekin", &s.ekin),
        op("ekin1", &s.ekin1),
        op("ekin2", &s.ekin2),
        op("c1x", &s.c1[0]),
        op("c1y", &s.c1[1]),
        op("c1z", &s.c1[2]),
        op("c2x", &s.c2[0]),
        op("c2y", &s.c2[1]),
        op("c2z", &s.c2[2]),
        op("vc1x", &s.vc1[0]),
        op("vc1y", &s.vc1[1]),
        op("vc1z", &s.vc1[2]),
        op("vc2x", &s.vc2[0]),
        op("vc2y", &s.vc2[1]),
        op("vc2z", &s.vc2[2]),
        op("v1x", &s.v1[0]),
        op("v1y", &s.v1[1]),
        op("v1z", &s.v1[2]),
        op("v2x", &s.v2[0]),
        op("v2y", &s.v2[1]),
        op("v2z", &s.v2[2]),
        op("meshposx", &s.meshpos[0]),
        op("meshvelx", &s.meshvel[0]),
        op("meshvelz", &s.meshvel[2]),
    };
    if (var.Int["statbox"]) {
      con.push_back(op("boxomm", &s.boxomm));
      con.push_back(op("boxomm2", &s.boxomm2));
      con.push_back(op("vommz", &s.vomm[2]));
    }
    if (var.Int["statvel"]) {
      con.push_back(op("vlmx", &s.vlm[0]));
      con.push_back(op("vlmy", &s.vlm[1]));
      con.push_back(op("vlmz", &s.vlm[2]));
      con.push_back(op("vl2x", &s.vl2[0]));
      con.push_back(op("vl2y", &s.vl2[1]));
      con.push_back(op("vl2z", &s.vl2[2]));
    }
    con.push_back(op("pmin", &s.pmin));
    con.push_back(op("pmax", &s.pmax));
    con.push_back(op("pd", &s.pd));
    con.push_back(op("pavg1", &s.pavg1));
    con.push_back(op("pavg2", &s.pavg2));
    if (var.Int["enstrophy"]) {
      con.push_back(op("enstr", &s.enstr));
    }
    if (var.Int["stat_area"]) {
      con.push_back(op("area", &s.area));
    }
    if (var.Int["stat_dissip"]) {
      con.push_back(op("dissip", &s.dissip));
      con.push_back(op("dissip1", &s.dissip1));
      con.push_back(op("dissip2", &s.dissip2));
      con.push_back(op("edis", &s.edis));
      con.push_back(op("edis1", &s.edis1));
      con.push_back(op("edis2", &s.edis2));
    }
    if (var.Int["stat_vofm"]) {
      s.vofm.resize(layers.size());
      for (auto l : layers) {
        auto sl = std::to_string(l);
        con.push_back(op("vofm_cells_vf" + sl, &s.vofm[l].cells_vf));
        con.push_back(op("vofm_cells_cl" + sl, &s.vofm[l].cells_cl));
        con.push_back(op("vofm_sum_vf" + sl, &s.vofm[l].sum_vf));
        con.push_back(op("vofm_hist" + std::to_string(l + 1), &s.vofm[l].hist));
      }
    }
    ost_ = std::make_shared<output::SerScalPlain<Scal>>(con, "stat.dat");
  }
}

template <class M>
void Hydro<M>::Init() {
  using namespace solver;
  using namespace solver::fluid_condition;
  auto sem = m.GetSem("init");
  struct {
    FieldCell<Scal> fcbody;
    FieldCell<bool> fcbodymask;
    Vars varbody;
  } * ctx(sem);
  if (sem.Nested()) {
    InitVf(fc_vf_, var, m);
  }
  if (sem("fields")) {
    fc_src_.Reinit(m, 0.);
    fc_src2_.Reinit(m, 0.);
    fc_srcm_.Reinit(m, 0.);

    // initial surface tension sigma
    fc_sig_.Reinit(m, 0);
    auto isig = CreateInitSig<M>(var);
    isig(fc_sig_, m);
    m.Comm(&fc_sig_);

    // initial velocity
    fc_vel_.Reinit(m, Vect(0));
    InitVel(fc_vel_, var, m);
    m.Comm(&fc_vel_);

    // global mesh size
    MIdx gs = m.GetGlobalSize();

    if (m.IsRoot()) {
      std::cout << "global mesh=" << gs << std::endl;
      std::cout << "surface tension dt=" << GetStDt() << std::endl;
      std::cout << "viscosity dt=" << GetVisDt() << std::endl;
    }

    // boundary conditions
    GetFluidFaceCond(var, m, mf_fluid_, mf_adv_);

    // boundary conditions for smoothing of volume fraction
    for (auto it : mf_fluid_) {
      IdxFace i = it.GetIdx();
      auto& cb = it.GetValue();
      size_t nci = cb->GetNci();
      if (cb.Get<Symm<M>>()) {
        mf_cond_vfsm_[i].Set<CondFaceReflect>(nci);
      } else {
        mf_cond_vfsm_[i].Set<CondFaceGradFixed<Scal>>(Scal(0), nci);
      }
    }
  }

  if (var.Int["bc_wall_init_vel"] && sem("bc_wall_init_vel")) {
    // velocity on walls from neighbour cells
    for (auto it : mf_fluid_) {
      IdxFace f = it.GetIdx();
      auto& cb = it.GetValue();
      if (auto cd = cb.Get<NoSlipWallFixed<M>>()) {
        IdxCell c = m.GetCell(f, cd->GetNci());
        cd->SetVelocity(fc_vel_[c]);
      }
    }
  }

  if (sem.Nested("initvort")) {
    if (var.Int["initvort"]) {
      InitVort();
    }
  }

  if (var.Int["wavelamb_vort"] && sem("wavelamb")) {
    FieldCell<Vect> fcvel(m);
    Vars vr;
    vr.String.Set("vel_init", "wavelamb");
    vr.Double.Set("wavelamb_a0", var.Double["wavelamb_a0"]);
    vr.Double.Set("wavelamb_xc", var.Double["wavelamb_xc"]);
    vr.Double.Set("wavelamb_h", var.Double["wavelamb_h"]);
    vr.Double.Set("wavelamb_k", var.Double["wavelamb_k"]);
    vr.Vect.Set("gravity", var.Vect["gravity"]);
    InitVel(fcvel, vr, m);
    for (auto c : m.AllCells()) {
      if (fcvel[c].sqrnorm() != 0) {
        fc_vel_[c] = fcvel[c];
      }
    }
  }

  if (var.Int["vel_init_noise"] && sem("noise")) {
    Vect vel0(var.Vect["noise_vel0"]);
    Vect vel1(var.Vect["noise_vel1"]);
    Vect vel2(var.Vect["noise_vel2"]);
    Vect per0(var.Vect["noise_per0"]);
    Vect per1(var.Vect["noise_per1"]);
    Vect per2(var.Vect["noise_per2"]);
    Vect k0 = Vect(2 * M_PI) / (per0 * m.GetCellSize());
    Vect k1 = Vect(2 * M_PI) / (per1 * m.GetCellSize());
    Vect k2 = Vect(2 * M_PI) / (per2 * m.GetCellSize());
    for (auto c : m.AllCells()) {
      auto x = m.GetCenter(c);
      fc_vel_[c] += vel0 * std::sin(k0.dot(x));
      fc_vel_[c] += vel1 * std::sin(k1.dot(x));
      fc_vel_[c] += vel2 * std::sin(k2.dot(x));
    }
  }

  if (var.Int["vel_init_random"] && sem("random")) {
    Scal amp = var.Double["random_amp"];
    Vect vel(var.Vect["random_vel"]);
    std::default_random_engine g(m.GetId());
    std::uniform_real_distribution<Scal> u(-amp, amp);
    for (auto c : m.Cells()) {
      Vect v = vel * u(g) / 7;
      for (auto q : m.Nci(c)) {
        IdxCell cn = m.GetCell(c, q);
        fc_vel_[cn] += v;
      }
      fc_vel_[c] += v;
    }
    m.Comm(&fc_vel_);
  }

  if (sem.Nested("smooth")) {
    solver::Smoothen(fc_vf_, mf_cond_vfsm_, m, var.Int["vf_init_sm"]);
  }

  if (sem.Nested("mixture")) {
    CalcMixture(fc_vf_);
  }

  if (sem("color-ini")) {
    if (var.Int["enable_color"]) {
      // initial color
      // TODO revise with bcast
      auto icl = CreateInitCl<M>(var, m.IsRoot());
      icl(fccl_, fc_vf_, m);
      m.Comm(&fccl_);
    } else {
      fccl_.Reinit(m, 0.);
    }
  }

  if (sem.Nested("cellcond")) {
    GetFluidCellCond(var, m, mc_velcond_, pdist_);
  }

  if (sem("body-mask")) {
    auto& varbody = ctx->varbody;
    varbody.String.Set("init_vf", var.String["body_init"]);
    varbody.String.Set("list_path", var.String["body_list_path"]);
    varbody.Int.Set("dim", var.Int["dim"]);
    varbody.Int.Set("list_ls", 0);
  }
  if (sem.Nested("body-mask")) {
    InitVf(ctx->fcbody, ctx->varbody, m);
  }
  if (sem("body-bc")) {
    // Step-wise approximation of bodies
    const Scal clear0 = var.Double["bcc_clear0"];
    const Scal clear1 = var.Double["bcc_clear1"];
    const Scal inletcl = var.Double["inletcl"];
    const Scal fill_vf = var.Double["bcc_fill"];
    auto& fc = ctx->fcbodymask;
    fc.Reinit(m, false);
    for (auto c : m.AllCells()) {
      fc[c] = (ctx->fcbody[c] > 0.5);
    }
    AppendBodyCond<M>(
        fc, var.String["body_bc"], m, clear0, clear1, inletcl, fill_vf, nullptr,
        mf_fluid_, mf_adv_);
  }

  if (sem("dt")) {
    const Scal dt = var.Double["dt0"];
    st_.dt = dt;
    st_.dta = dt;
    if (m.IsLead()) {
      this->var_mutable.Double.Set("dt", st_.dt);
      this->var_mutable.Double.Set("dta", st_.dta);
    }
  }

  if (sem("solv")) {
    InitFluid();

    InitAdvection();

    st_.iter = 0;
    st_.t = fs_->GetTime();

    if (m.IsLead()) {
      this->var_mutable.Int.Set("iter", st_.iter);
      this->var_mutable.Double.Set("t", st_.t);
    }

    InitStat();

    // enable curl component of velocity
    {
      auto dl = GetWords(var.String["dumplist"]);
      if (dl.count("vcurlx") || dl.count("vcurly") || dl.count("vcurlz")) {
        vcurl_ = true;
      } else {
        vcurl_ = false;
      }
    }

    if (var.Int["fill_halo_nan"]) {
      std::vector<std::pair<IdxFace, size_t>> vf;
      for (auto& p : mf_adv_) {
        vf.emplace_back(p.GetIdx(), p.GetValue().GetNci());
      }
      m.SetNanFaces(vf);
    }

    if (m.IsLead()) {
      events_ = std::unique_ptr<Events>(
          new Events(this->var_mutable, m.IsRoot(), m.IsLead()));
      events_->Parse();
    }
  }
  if (var.Int["dumpbc"] && sem.Nested()) {
    DumpBcFaces(mf_adv_, mf_fluid_, "bc.vtk", m);
  }
}

template <class M>
Hydro<M>::Hydro(Vars& var0, const MyBlockInfo& bi, Par& par)
    : KernelMeshPar<M, Par>(var0, bi, par)
    , st_{}
    , dumper_(var, "dump_field_")
    , dmptraj_(var, "dump_traj_")
    , dmptrep_(var, "dump_trep_") {}

template <class M>
void Hydro<M>::CalcStat() {
  auto sem = m.GetSem("stat");

  auto& s = st_;
  auto& fa = as_->GetField();
  auto& fv = fs_->GetVelocity();
  auto& fp = fs_->GetPressure();

  if (sem("stat-add")) {
    s.Add(fa, "vf", m);
    s.Add(fv, 0, "vx", m);
    s.Add(fv, 1, "vy", m);
    s.Add(fv, 2, "vz", m);
    s.Add(fp, "p", m);
  }
  if (sem("stat-print")) {
    if (var.Int["report_stat"] && m.IsRoot()) {
      s.Print(std::cout);
    }
    s.Clear();
  }

  if (sem("local")) {
    // Store vc1 and vc2
    s.vc1 = s.c1;
    s.vc2 = s.c2;

    // mass, center, velocity, kinetic energy
    s.m1 = 0;
    s.m2 = 0;
    s.c1 = Vect(0);
    s.c2 = Vect(0);
    s.v1 = Vect(0);
    s.v2 = Vect(0);
    s.ekin = 0;
    s.ekin1 = 0;
    s.ekin2 = 0;
    for (auto i : m.Cells()) {
      Scal o = m.GetVolume(i);
      Scal a2 = fa[i];
      Scal a1 = 1. - a2;
      Vect v = fv[i];
      Vect x = m.GetCenter(i);

      s.m1 += a1 * o;
      s.m2 += a2 * o;
      s.c1 += x * (a1 * o);
      s.c2 += x * (a2 * o);
      s.v1 += v * (a1 * o);
      s.v2 += v * (a2 * o);
      s.ekin += 0.5 * v.dot(v) * fc_rho_[i] * o;
      s.ekin1 += 0.5 * v.dot(v) * fc_rho_[i] * o * a1;
      s.ekin2 += 0.5 * v.dot(v) * fc_rho_[i] * o * a2;
    }

    m.Reduce(&s.m1, "sum");
    m.Reduce(&s.m2, "sum");
    m.Reduce(&s.ekin, "sum");
    m.Reduce(&s.ekin1, "sum");
    m.Reduce(&s.ekin2, "sum");
    for (size_t d = 0; d < dim; ++d) {
      m.Reduce(&s.c1[d], "sum");
      m.Reduce(&s.c2[d], "sum");
      m.Reduce(&s.v1[d], "sum");
      m.Reduce(&s.v2[d], "sum");
    }

    // pressure
    s.pmin = 1e10;
    s.pmax = -1e10;
    s.pavg1 = 0.;
    s.pavg2 = 0.;
    for (auto c : m.Cells()) {
      Scal o = m.GetVolume(c);
      Scal a2 = fa[c];
      Scal p = fp[c];
      s.pmin = std::min(s.pmin, p);
      s.pmax = std::max(s.pmax, p);
      s.pavg1 += p * (1. - a2) * o;
      s.pavg2 += p * a2 * o;
    }
    m.Reduce(&s.pmin, "min");
    m.Reduce(&s.pmax, "max");
    m.Reduce(&s.pavg1, "sum");
    m.Reduce(&s.pavg2, "sum");

    if (var.Int["statvel"]) {
      s.vlm = Vect(0);
      s.vl2 = Vect(0);
      Vect v0(var.Vect["vel"]);
      for (auto c : m.Cells()) {
        Scal o = m.GetVolume(c);
        Scal a2 = fa[c];
        Vect v = fv[c];
        auto dv = (v - v0).abs();
        for (size_t d = 0; d < dim; ++d) {
          s.vlm[d] = std::max(s.vlm[d], dv[d] * a2);
          s.vl2[d] += sqr(dv[d]) * o * a2;
        }
      }
      for (size_t d = 0; d < dim; ++d) {
        m.Reduce(&s.vlm[d], "max");
        m.Reduce(&s.vl2[d], "sum");
      }
    }

    if (var.Int["statbox"] || var.Int["enstrophy"]) {
      CalcVort();
    }

    // XXX: adhoc: also controls s.vomm
    if (var.Int["statbox"]) {
      // XXX requires CalcVort above
      Vect xa(var.Vect["statboxa"]);
      Vect xb(var.Vect["statboxb"]);
      Vect x2a(var.Vect["statbox2a"]);
      Vect x2b(var.Vect["statbox2b"]);
      Vect h = m.GetCellSize();
      size_t dm = (xb - xa).argmin();
      size_t dm2 = (x2b - x2a).argmin();
      // box size at least h
      for (size_t d = 0; d < dim; ++d) {
        xb[d] = std::max<Scal>(xb[d], xa[d] + h[d]);
        x2b[d] = std::max<Scal>(x2b[d], x2a[d] + h[d]);
      }
      // integrate
      s.boxomm = 0.;
      s.boxomm2 = 0.;
      for (auto c : m.Cells()) {
        auto xc = m.GetCenter(c);
        if (xa <= xc && xc <= xb) {
          s.boxomm += m.GetVolume(c) * fcom_[c][dm];
        }
        if (x2a <= xc && xc <= x2b) {
          s.boxomm2 += m.GetVolume(c) * fcom_[c][dm2];
        }
      }
      // divide by smallest dimension to get integral over slice
      s.boxomm /= h[dm];
      s.boxomm2 /= h[dm2];
      m.Reduce(&s.boxomm, "sum");
      m.Reduce(&s.boxomm2, "sum");

      // vomm
      s.vomm = Vect(0);
      s.vommw = 0;
      for (auto c : m.Cells()) {
        s.vomm += fv[c] * fcomm_[c];
        s.vommw += fcomm_[c];
      }
      for (size_t d = 0; d < dim; ++d) {
        m.Reduce(&s.vomm[d], "sum");
      }
      m.Reduce(&s.vommw, "sum");
    }

    if (var.Int["enstrophy"]) {
      // XXX requires CalcVort above
      s.enstr = 0.;
      for (auto c : m.Cells()) {
        s.enstr += 0.5 * sqr(fcomm_[c]) * fc_rho_[c] * m.GetVolume(c);
      }
      m.Reduce(&s.enstr, "sum");
    }
    // surface area
    if (var.Int["stat_area"]) {
      s.area = 0;
      if (auto as = dynamic_cast<ASVM*>(as_.get())) {
        using R = Reconst<Scal>;
        auto& fcn = *as->GetNormal()[0];
        auto& fca = *as->GetAlpha()[0];
        auto& fcvf = as->GetField(solver::Layers::time_curr, 0);
        Vect h = m.GetCellSize();
        for (auto c : m.Cells()) {
          if (fcvf[c] > 0. && fcvf[c] < 1. && !IsNan(fca[c])) {
            auto xx = R::GetCutPoly2(fcn[c], fca[c], h);
            Scal ar = std::abs(R::GetArea(xx, fcn[c]));
            s.area += ar;
          }
        }
        if (IsNan(s.area)) {
          s.area = 0;
        }
        m.Reduce(&s.area, "sum");
      }
    }
    if (var.Int["stat_dissip"]) {
      s.dissip = 0.;
      s.dissip1 = 0.;
      s.dissip2 = 0.;
      CalcStrain();
      auto& fcmu = fc_mu_;
      auto& fcd = fc_strain_;
      auto& fcvf = as_->GetField();
      for (auto c : m.Cells()) {
        Scal o = m.GetVolume(c);
        Scal mu = fcmu[c];
        Scal d = fcd[c];
        Scal vf = fcvf[c];
        s.dissip += 2. * mu * d * o;
        s.dissip1 += 2. * mu * d * (1. - vf) * o;
        s.dissip2 += 2. * mu * d * vf * o;
      }
      m.Reduce(&s.dissip, "sum");
      m.Reduce(&s.dissip1, "sum");
      m.Reduce(&s.dissip2, "sum");
    }
    if (var.Int["stat_vofm"]) {
      if (auto as = dynamic_cast<ASVM*>(as_.get())) {
        // clear
        for (auto l : layers) {
          auto& v = s.vofm[l];
          v.cells_vf = 0;
          v.cells_cl = 0;
          v.sum_vf = 0;
          v.hist = 0;
        }
        for (auto l : layers) {
          auto& v = s.vofm[l];
          auto& vf = *as->GetFieldM()[l];
          auto& cl = *as->GetColor()[l];
          for (auto c : m.Cells()) {
            v.cells_vf += (vf[c] > 0 ? 1 : 0);
            v.cells_cl += (cl[c] != kClNone ? 1 : 0);
            v.sum_vf += vf[c] * m.GetVolume(c);
          }
          m.Reduce(&v.cells_vf, "sum");
          m.Reduce(&v.cells_cl, "sum");
          m.Reduce(&v.sum_vf, "sum");
        }
        for (auto c : m.Cells()) {
          size_t cnt = 0;
          for (auto l : layers) {
            if ((*as->GetFieldM()[l])[c] > 0) {
              ++cnt;
            }
          }
          if (cnt > 0) {
            assert(cnt - 1 >= 0 && cnt - 1 < layers.size());
            s.vofm[cnt - 1].hist += 1;
          }
        }
        for (auto l : layers) {
          m.Reduce(&s.vofm[l].hist, "sum");
        }
      }
    }
  }

  if (sem("reduce")) {
    Scal im1 = (s.m1 == 0 ? 0. : 1. / s.m1);
    Scal im2 = (s.m2 == 0 ? 0. : 1. / s.m2);
    s.c1 *= im1;
    s.c2 *= im2;
    s.v1 *= im1;
    s.v2 *= im2;
    s.pavg1 *= im1;
    s.pavg2 *= im2;

    if (s.m20 == 0.) {
      s.m20 = s.m2;
    } else {
      s.m2d = (s.m2 - s.m20) / s.m20;
    }

    if (s.vommw != 0) {
      s.vomm /= s.vommw;
    }

    Scal dt = fs_->GetTimeStep();

    // Moving mesh
    s.c1 += st_.meshpos;
    s.c2 += st_.meshpos;
    s.vc1 = (s.c1 - s.vc1) / dt;
    s.vc2 = (s.c2 - s.vc2) / dt;

    // dissipated energy
    s.edis += s.dissip * dt;
    s.edis1 += s.dissip1 * dt;
    s.edis2 += s.dissip2 * dt;

    if (const std::string* s = var.String("meshvel_auto")) {
      Vect v(0);
      if (*s == "v") {
        v = st_.v2;
      } else if (*s == "vc") {
        v = st_.vc2;
      } else if (*s == "vomm") {
        v = st_.vomm;
      } else {
        throw std::runtime_error("Unknown meshvel_auto=" + *s);
      }
      Vect mask(var.Vect["meshvel_mask"]); // components 0 or 1
      v *= mask;
      double w = var.Double["meshvel_weight"];
      Vect* meshvel;
      if (auto fs = dynamic_cast<FSS*>(fs_.get())) {
        meshvel = &(fs->GetPar()->meshvel);
      } else if (auto fs = dynamic_cast<FSP*>(fs_.get())) {
        meshvel = &(fs->GetPar()->meshvel);
      } else {
        meshvel = nullptr;
      }
      Vect vp = *meshvel;
      (*meshvel) = v * w + vp * (1. - w);

      st_.meshvel = *meshvel;
      st_.meshpos += st_.meshvel * st_.dt;
    }

    if (var.Int["statvel"]) {
      for (size_t d = 0; d < dim; ++d) {
        s.vl2[d] = std::sqrt(s.vl2[d] * im2);
      }
      s.pd = s.pmax - s.pmin;
    }
  }

  if (sem("vfslip")) {
    auto kslip = var.Double["kslip"];
    if (kslip != 0) {
      Vect slipvel(var.Vect["slipvel"]);
      // XXX: adhoc, overwrite wall conditions
      auto& fa = as_->GetField();
      for (auto it : mf_fluid_) {
        IdxFace f = it.GetIdx();
        solver::CondFaceFluid* cb = it.GetValue().Get();
        if (auto cd =
                dynamic_cast<solver::fluid_condition::NoSlipWallFixed<M>*>(
                    cb)) {
          size_t nci = cd->GetNci();
          IdxCell c = m.GetCell(f, nci);
          cd->SetVelocity(slipvel * kslip * fa[c]);
        }
      }
    }

    // XXX: slip velocity penalization
    const Scal penalslip = var.Double["penalslip"];
    if (penalslip != 0) {
      Scal dt = fs_->GetTimeStep();
      Vect slipvel(var.Vect["slipvel"]);
      // const auto& fa = as_->GetField();
      const auto& fa = fc_smvf_;
      const auto& fv = fs_->GetVelocity();
      for (auto it : mf_fluid_) {
        IdxFace f = it.GetIdx();
        solver::CondFaceFluid* cb = it.GetValue().Get();
        if (auto cd =
                dynamic_cast<solver::fluid_condition::NoSlipWallFixed<M>*>(
                    cb)) {
          size_t nci = cd->GetNci();
          IdxCell c = m.GetCell(f, nci);
          Scal sgn = (slipvel - fv[c]).dot(slipvel);
          if (sgn > 0) {
            fc_force_[c] +=
                (slipvel - fv[c]) * (fc_rho_[c] * penalslip * fa[c] / dt);
          }
        }
      }
    }
    const Scal slipnormal = var.Double["slipnormal"];
    if (slipnormal != 0) {
      const auto& fa = fc_smvf_;
      for (auto it : mf_fluid_) {
        IdxFace f = it.GetIdx();
        solver::CondFaceFluid* cb = it.GetValue().Get();
        if (auto cd =
                dynamic_cast<solver::fluid_condition::NoSlipWallFixed<M>*>(
                    cb)) {
          size_t nci = cd->GetNci();
          IdxCell c = m.GetCell(f, nci);
          fc_force_[c] += m.GetNormal(f) * ((nci == 1 ? 1 : -1) * fc_rho_[c] *
                                            slipnormal * fa[c]);
        }
      }
    }
  }

  if (sem("young")) {
    if (var.Int["youngbc"]) {
      InitYoung();
      for (auto it : mf_fluid_) {
        IdxFace f = it.GetIdx();
        Vect x = m.GetCenter(f);
        solver::CondFaceFluid* cb = it.GetValue().Get();
        if (auto cd =
                dynamic_cast<solver::fluid_condition::NoSlipWallFixed<M>*>(
                    cb)) {
          cd->SetVelocity(GetYoungVel(x));
        }
      }
    }
  }
}

template <class M>
void Hydro<M>::CalcDt() {
  auto sem = m.GetSem("dt");

  if (sem("local")) {
    st_.t = fs_->GetTime();
    if (m.IsLead()) {
      this->var_mutable.Double["t"] = st_.t;
    }

    st_.dtt = fs_->GetAutoTimeStep();
    m.Reduce(&st_.dtt, "min");
  }
  if (sem("reduce")) {
    // set from cfl if defined
    if (auto* cfl = var.Double("cfl")) {
      st_.dt = st_.dtt * (*cfl);
      st_.dt = std::min<Scal>(st_.dt, var.Double["dtmax"]);
    }

    // constraint from surface tension
    st_.dt = std::min<Scal>(st_.dt, GetStDt());

    // constraint from viscosity
    st_.dt = std::min<Scal>(st_.dt, GetVisDt());

    fs_->SetTimeStep(st_.dt);
    if (m.IsLead()) {
      this->var_mutable.Double["dt"] = st_.dt;
    }

    // set from cfla if defined
    if (auto* cfla = var.Double("cfla")) {
      st_.dta = st_.dtt * (*cfla);
      st_.dta = std::min<Scal>(st_.dta, var.Double["dtmax"]);
    }

    // round up dta to such that dt / dta is integer
    Scal dt = fs_->GetTime() + fs_->GetTimeStep() - as_->GetTime();
    st_.dta = dt / std::max(1, int(dt / st_.dta + 0.5));

    as_->SetTimeStep(st_.dta);
    if (m.IsLead()) {
      this->var_mutable.Double["dta"] = st_.dta;
    }
  }
}

template <class M>
void Hydro<M>::AppendSurfaceTension(
    FieldFace<Scal>& ffst, const FieldCell<Scal>& fcu,
    const FieldCell<Scal>& fck, const FieldFace<Scal>& ffsig) {
  for (auto f : m.Faces()) {
    IdxCell cm = m.GetCell(f, 0);
    IdxCell cp = m.GetCell(f, 1);
    Scal um = fcu[cm];
    Scal up = fcu[cp];
    Scal k = (std::abs(um - 0.5) < std::abs(up - 0.5) ? fck[cm] : fck[cp]);
    Scal hi = m.GetArea(f) / m.GetVolume(cp);
    Scal ga = (up - um) * hi;
    if (ga != 0.) {
      k = (IsNan(k) ? 0 : k);
      ffst[f] += ga * k * ffsig[f];
    }
  }
}

template <class M>
void Hydro<M>::AppendSurfaceTension(
    FieldFace<Scal>& ffst, const GRange<size_t>& layers,
    const solver::Multi<const FieldCell<Scal>*> fcu,
    const solver::Multi<const FieldCell<Scal>*> fccl,
    const solver::Multi<const FieldCell<Scal>*> fck,
    const FieldFace<Scal>& ffsig) {
  for (auto f : m.Faces()) {
    IdxCell cm = m.GetCell(f, 0);
    IdxCell cp = m.GetCell(f, 1);
    std::set<Scal> s;
    for (auto i : layers) {
      Scal clm = (*fccl[i])[cm];
      Scal clp = (*fccl[i])[cp];
      if (clm != kClNone) s.insert(clm);
      if (clp != kClNone) s.insert(clp);
    }
    for (auto cl : s) {
      Scal um = 0;
      Scal up = 0;
      Scal km = 0;
      Scal kp = 0;
      for (auto i : layers) {
        if ((*fccl[i])[cm] == cl) {
          um = (*fcu[i])[cm];
          km = (*fck[i])[cm];
        }
        if ((*fccl[i])[cp] == cl) {
          up = (*fcu[i])[cp];
          kp = (*fck[i])[cp];
        }
      }
      Scal k = (std::abs(um - 0.5) < std::abs(up - 0.5) ? km : kp);
      Scal hi = m.GetArea(f) / m.GetVolume(cp);
      Scal ga = (up - um) * hi;
      if (ga != 0.) {
        k = (IsNan(k) ? 0 : k);
        ffst[f] += ga * k * ffsig[f];
      }
    }
  }
}

template <class M>
void Hydro<M>::CalcSurfaceTension(
    const FieldCell<Scal>& fcvf, const FieldFace<Scal>& ffvfsm) {
  // volume fration gradient on cells
  FieldCell<Vect> gc = solver::Gradient(ffvfsm, m); // [s]
  // volume fration gradient on faces
  FieldFace<Vect> gf = solver::Interpolate(gc, GetBcVz(), m); // [i]

  auto st = var.String["surftens"];
  if (st == "div") { // divergence of tensor (Hu,Adam 2001)
    auto stdiag = var.Double["stdiag"];
    for (auto c : m.Cells()) {
      Vect r(0);
      for (auto q : m.Nci(c)) {
        IdxFace f = m.GetFace(c, q);
        const auto& g = gf[f];
        // TODO: revise 1e-6
        auto n = g / (g.norm() + 1e-6); // inner normal
        auto s = m.GetOutwardSurface(c, q);
        r += s * (g.norm() * stdiag) - g * s.dot(n);
      }
      r /= m.GetVolume(c);
      // here: r = stdiag*div(|g|I) - div(g g/|g|)
      fc_force_[c] += r * fc_sig_[c];
    }
  } else if (st == "kn") { // curvature * normal
    FieldFace<Scal> ff_st(m, 0.); // surface tension projections

    ff_sig_ = solver::Interpolate(fc_sig_, GetBcSz(), m);

    if (auto as = dynamic_cast<ASVM*>(as_.get())) {
      AppendSurfaceTension(
          ff_st, layers, as->GetFieldM(), as->GetColor(), fck_,
          ff_sig_);
    } else if (auto as = dynamic_cast<ASV*>(as_.get())) {
      AppendSurfaceTension(ff_st, as_->GetField(), fck_[0], ff_sig_);
    }

    // zero on boundaries
    for (auto it : mf_fluid_) {
      IdxFace f = it.GetIdx();
      ff_st[f] = 0.;
    }

    // Surface tension decay between x0 and x1
    // XXX: adhoc TODO: revise
    const Scal x0 = var.Double["zerostx0"];
    const Scal x1 = var.Double["zerostx1"];
    // apply
    for (auto f : m.Faces()) {
      Scal x = m.GetCenter(f)[0];
      if (x > x0) {
        ff_st[f] *= std::max(0., (x1 - x) / (x1 - x0));
      }
    }

    // Append to force
    for (auto f : m.Faces()) {
      ffbp_[f] += ff_st[f];
    }

    // Append Marangoni stress
    if (var.Int["marangoni"]) {
      if (auto as = dynamic_cast<ASVM*>(as_.get())) {
        using R = Reconst<Scal>;
        auto fc_gsig = solver::Gradient(ff_sig_, m);
        auto& fcn = *as->GetNormal()[0];
        auto& fca = *as->GetAlpha()[0];
        Vect h = m.GetCellSize();
        for (auto c : m.Cells()) {
          if (fcvf[c] > 0. && fcvf[c] < 1. && !IsNan(fca[c])) {
            Vect g = fc_gsig[c]; // sigma gradient
            Vect n = fcn[c] / fcn[c].norm(); // unit normal to interface
            Vect gt = g - n * g.dot(n);
            auto xx = R::GetCutPoly2(fcn[c], fca[c], h);
            Scal ar = std::abs(R::GetArea(xx, fcn[c]));
            Scal vol = h.prod();
            fc_force_[c] += gt * (ar / vol);
          }
        }
      }
    }
  } else {
    throw std::runtime_error("Unknown surftens=" + st);
  }
}

template <class M>
void Hydro<M>::CalcMixture(const FieldCell<Scal>& fc_vf0) {
  auto sem = m.GetSem("mixture");

  if (sem("init")) {
    fc_mu_.Reinit(m);
    fc_rho_.Reinit(m);
    fc_force_.Reinit(m, Vect(0));
    ffbp_.Reinit(m, 0);
    fc_smvf_ = fc_vf0;

    // XXX: oscillating source
    Scal source_mag = var.Double["source_mag"];
    if (source_mag != 0) {
      Scal mag = source_mag;
      Scal mag0 = var.Double["source_mag0"]; // constant component
      Scal freq = var.Double["source_freq"];
      Scal wly = var.Double["source_wly"];
      Scal mexp = var.Double["source_mexp"];
      Scal mexp0 = var.Double["source_mexp0"];
      Scal pi = M_PI;
      Scal s = std::sin(st_.t * freq * 2. * pi);
      fc_src_.Reinit(m, 0);
      for (auto c : m.Cells()) {
        const Vect x = m.GetCenter(c);
        const Scal sy = std::cos(2. * pi * x[1] / wly);
        const Scal vf = fc_vf0[c];
        Scal q = s * sy * mag * vf;
        Scal q0 = mag0 * vf;
        if (st_.m20 > 0 && st_.m2 > 0) {
          q *= std::pow(st_.m2 / st_.m20, mexp);
          q0 *= std::pow(st_.m2 / st_.m20, mexp0);
        }
        fc_src_[c] = q + q0;
      }
    }

    // XXX: oscillating force
    Scal force_mag = var.Double["force_mag"];
    if (force_mag != 0) {
      Scal force_freq = var.Double["force_freq"];
      Scal force_wly = var.Double["force_wly"];
      Scal pi = M_PI;
      Scal s = std::sin(st_.t * force_freq * 2. * pi);
      for (auto c : m.Cells()) {
        Vect x = m.GetCenter(c);
        Scal sy = std::cos(2. * pi * x[1] / force_wly);
        fc_force_[c][0] += s * sy * force_mag * fc_vf0[c];
      }
    }
  }

  if (sem.Nested("smooth")) {
    solver::Smoothen(fc_smvf_, mf_cond_vfsm_, m, var.Int["vfsmooth"]);
  }

  if (sem.Nested("smoothnode")) {
    SmoothenNode(fc_smvf_, m, var.Int["vfsmoothnode"]);
  }

  if (sem("calc")) {
    FieldCell<Scal>& a = fc_smvf_;
    FieldFace<Scal>& af = ff_smvf_;
    af = solver::Interpolate(a, mf_cond_vfsm_, m);

    const Vect force(var.Vect["force"]);
    const Vect grav(var.Vect["gravity"]);
    const Scal r1(var.Double["rho1"]);
    const Scal r2(var.Double["rho2"]);
    const Scal m1(var.Double["mu1"]);
    const Scal m2(var.Double["mu2"]);

    // Init density and viscosity
    for (auto c : m.AllCells()) {
      const Scal v2 = a[c];
      const Scal v1 = 1. - v2;
      fc_rho_[c] = r1 * v1 + r2 * v2;
      fc_mu_[c] = m1 * v1 + m2 * v2;
    }

    FieldFace<Scal> ff_rho(m);
    // Init density and viscosity
    for (auto f : m.AllFaces()) {
      const Scal v2 = af[f];
      const Scal v1 = 1. - v2;
      ff_rho[f] = r1 * v1 + r2 * v2;
    }

    // Append gravity to force
    for (auto f : m.AllFaces()) {
      Vect n = m.GetNormal(f);
      ffbp_[f] += force.dot(n);
      ffbp_[f] += grav.dot(n) * ff_rho[f];
    }

    // Surface tension
    if (var.Int["enable_surftens"] && as_) {
      CalcSurfaceTension(fc_vf0, af);
    }

    // vortex force
    Scal force_vort = var.Double["force_vort_g"];
    if (force_vort != 0) {
      Scal r = var.Double["force_vort_r"];
      Vect xc(var.Vect["force_vort_c"]);
      for (auto c : m.Cells()) {
        Vect x = m.GetCenter(c);
        Vect dx = x - xc;
        Scal q = std::exp(-dx.sqrnorm() / sqr(r)) * force_vort;
        Scal fx = -dx[1];
        Scal fy = dx[0];
        fc_force_[c] = Vect(fx, fy, 0.) * q * fc_rho_[c];
      }
    }

    // moving force on the interface
    auto fmov = [this, &a](std::string pre) {
      Vect force_mov(var.Vect[pre]);
      if (force_mov.sqrnorm()) {
        Vect x0(var.Vect[pre + "_x0"]);
        Vect x1(var.Vect[pre + "_x1"]);
        Scal t0 = var.Double[pre + "_t0"];
        Scal t1 = var.Double[pre + "_t1"];
        Vect sig(var.Vect[pre + "_sig"]);
        Scal pi = M_PI;
        int edim = var.Int["dim"];

        Scal t = (st_.t - t0) / (t1 - t0);
        if (t >= 0 && t <= 1) {
          if (var.Int[pre + "_parab"]) {
            t = t * t;
          }
          for (auto c : m.Cells()) {
            Vect xt = x0 + (x1 - x0) * t;
            Vect r = (xt - m.GetCenter(c)) / sig;
            Scal k = std::exp(-r.sqrnorm() * 0.5) /
                     (std::pow(2 * pi, 1. / edim) * sig.prod());
            Scal vf = a[c];
            fc_force_[c] += force_mov * (k * fc_rho_[c] * vf * (1 - a[c]) * 2);
          }
        }
      }
    };

    fmov("force_mov");
    fmov("force_mov2");

    // Kolmogorov forcing
    if (var.Int["force_kolm"]) {
      for (auto f : m.AllFaces()) {
        Vect n = m.GetNormal(f);
        Vect x = m.GetCenter(f);
        ffbp_[f] += Vect(std::sin(x[1]), 0., 0.).dot(n);
      }
    }

    // Kolmogorov forcing as acceleration
    if (var.Int["force_kolm_accel"]) {
      for (auto f : m.AllFaces()) {
        Vect n = m.GetNormal(f);
        Vect x = m.GetCenter(f);
        ffbp_[f] += Vect(std::sin(x[1]), 0., 0.).dot(n) * ff_rho[f];
      }
    }

    // zero force in z if 2D
    if (var.Int["dim"] <= 2) {
      for (auto f : m.Faces()) {
        using Dir = typename M::Dir;
        if (m.GetIndexFaces().GetDir(f) == Dir::k) {
          ffbp_[f] = 0.; // XXX: zero in z
        }
      }
    }
  }
}

template <class M>
void Hydro<M>::DumpFields() {
  auto sem = m.GetSem("dumpfields");
  struct {
    std::array<Multi<FieldCell<Scal>>, dim> im;
    FieldCell<Scal> fc_cellcond;
  } * ctx(sem);
  if (vcurl_) {
    if (sem("vcurl-pre")) {
      CalcVort();
      fc_vel_ = fcom_;
    }
    if (sem.Nested("vcurl-solve")) {
      InitVort();
    }
    if (sem("vcurl-copy")) {
      fcvcurl_ = fc_vel_;
    }
  }
  if (sem("dump")) {
    if (m.IsRoot()) {
      dumper_.Report();
    }

    auto dl = GetWords(var.String["dumplist"]);
    auto& fcv = fs_->GetVelocity();
    if (dl.count("vx")) m.Dump(&fcv, 0, "vx");
    if (dl.count("vy")) m.Dump(&fcv, 1, "vy");
    if (dl.count("vz")) m.Dump(&fcv, 2, "vz");
    if (dl.count("p")) m.Dump(&fs_->GetPressure(), "p");
    if (dl.count("vf")) m.Dump(&as_->GetField(), "vf");
    if (dl.count("rho")) m.Dump(&fc_rho_, "rho");
    if (dl.count("mu")) m.Dump(&fc_mu_, "mu");
    if (dl.count("sig")) m.Dump(&fc_sig_, "sig");
    if (dl.count("bc")) m.Dump(&fcbc_, "bc");
    if (dl.count("cellcond")) {
      auto& fc = ctx->fc_cellcond;
      fc.Reinit(m, 0);
      for (auto it : mc_velcond_) {
        fc[it.GetIdx()] = 1;
      }
      m.Dump(&fc, "cellcond");
    }
    if (var.Int["youngbc"]) {
      if (dl.count("yvx")) m.Dump(&fcyv_, 0, "yvx");
      if (dl.count("yvy")) m.Dump(&fcyv_, 1, "yvy");
      if (dl.count("yvz")) m.Dump(&fcyv_, 2, "yvz");
    }
    if (dl.count("omx") || dl.count("omy") || dl.count("omz") ||
        dl.count("omm") || dl.count("omcalc")) {
      CalcVort();
      if (dl.count("omx")) m.Dump(&fcom_, 0, "omx");
      if (dl.count("omy")) m.Dump(&fcom_, 1, "omy");
      if (dl.count("omz")) m.Dump(&fcom_, 2, "omz");
      if (dl.count("omm")) m.Dump(&fcomm_, "omm");
    }
    if (dl.count("vcurlx")) m.Dump(&fcvcurl_, 0, "vcurlx");
    if (dl.count("vcurly")) m.Dump(&fcvcurl_, 1, "vcurly");
    if (dl.count("vcurlz")) m.Dump(&fcvcurl_, 2, "vcurlz");
    if (dl.count("dis") || dl.count("strain")) {
      CalcStrain();
      if (dl.count("strain")) m.Dump(&fcomm_, "strain");
      if (dl.count("dis")) {
        fctmp_ = fc_strain_;
        for (auto c : m.Cells()) {
          fctmp_[c] *= 2. * fc_mu_[c];
        }
        m.Dump(&fctmp_, "dis");
      }
    }
    if (dl.count("div")) {
      fcdiv_ = GetDiv();
      m.Dump(&fcdiv_, "div");
    }
    if (auto as = dynamic_cast<ASV*>(as_.get())) {
      if (dl.count("nx")) m.Dump(&as->GetNormal(), 0, "nx");
      if (dl.count("ny")) m.Dump(&as->GetNormal(), 1, "ny");
      if (dl.count("nz")) m.Dump(&as->GetNormal(), 2, "nz");
      if (dl.count("cls")) m.Dump(&as->GetColor(), "cls");
      if (dl.count("k")) m.Dump(&as->GetCurv(), "k");
    }
    if (auto as = dynamic_cast<ASVM*>(as_.get())) {
      for (auto l : layers) {
        auto sl = std::to_string(l);
        if (dl.count("vf" + sl)) m.Dump(as->GetFieldM()[l], "vf" + sl);
        if (dl.count("cl" + sl)) m.Dump(as->GetColor()[l], "cl" + sl);
        if (dl.count("nx" + sl)) m.Dump(as->GetNormal()[l], 0, "nx" + sl);
        if (dl.count("ny" + sl)) m.Dump(as->GetNormal()[l], 1, "ny" + sl);
        if (dl.count("nz" + sl)) m.Dump(as->GetNormal()[l], 2, "nz" + sl);
        if (dl.count("k" + sl)) m.Dump(as->GetCurv()[l], "k" + sl);
      }

      // combined colors
      if (dl.count("cls")) m.Dump(&as->GetColorSum(), "cls");

      // image
      auto conv = [&](size_t d, size_t l, Multi<FieldCell<Scal>>& fc) {
        fc.resize(layers);
        fc[l].Reinit(m);
        for (auto c : m.Cells()) {
          fc[l][c] = as->GetImage(l, c)[d];
        }
        return &fc[l];
      };
      for (auto d : {0, 1, 2}) {
        for (auto l : layers) {
          std::stringstream st;
          st << "im"
             << "xyz"[d] << l;
          std::string s = st.str();
          if (dl.count(s)) {
            m.Dump(conv(d, l, ctx->im[d]), s);
          }
        }
      }
    }
  }
  if (sem()) {
  } // FIXME: empty stage for dump, or ctx is destroyed before dump
}

template <class M>
void Hydro<M>::Dump() {
  auto sem = m.GetSem("dump");
  struct {
    Multi<FieldCell<MIdx>> fcim;
  } * ctx(sem);
  if (sem.Nested("fields")) {
    if (dumper_.Try(st_.t, st_.dt)) {
      DumpFields();
    }
  }
  if (dmptraj_.Try(st_.t, st_.dt)) {
    if (sem("copyimage")) {
      ctx->fcim.resize(layers);
      ctx->fcim.InitAll(FieldCell<MIdx>(m));
      if (auto as = dynamic_cast<ASVM*>(as_.get())) {
        for (auto c : m.AllCells()) {
          for (auto l : layers) {
            ctx->fcim[l][c] = as->GetImage(l, c);
          }
        }
      } else if (auto as = dynamic_cast<ASV*>(as_.get())) {
        for (auto c : m.AllCells()) {
          ctx->fcim[0][c] = as->GetImage(c);
        }
      }
    }
    if (sem.Nested("trajdump")) {
      if (var.Int["enable_color"]) {
        solver::Multi<const FieldCell<Scal>*> fcu(layers);
        solver::Multi<const FieldCell<Scal>*> fccl(layers);
        if (auto as = dynamic_cast<ASVM*>(as_.get())) {
          fcu = as->GetFieldM();
          fccl = as->GetColor();
        } else if (auto as = dynamic_cast<ASV*>(as_.get())) {
          fcu[0] = &as->GetField();
          fccl[0] = &as->GetColor();
        }
        DumpTraj(
            m, true, var, dmptraj_.GetN(), st_.t, layers, fcu, fccl, ctx->fcim,
            fs_->GetPressure(), fs_->GetVelocity(), fcvm_, st_.dt);
      }
    }
  }
  if (sem("dmptrep")) {
    if (m.IsRoot() && dmptrep_.Try(st_.t, st_.dt)) {
      std::string s = GetDumpName("trep", ".log", dmptrep_.GetN());
      m.TimerReport(s);
      std::cout << std::fixed << std::setprecision(8) << "timer report"
                << " t=" << st_.t << " to " << s << std::endl;
    }
  }
  if (sem("dumpstat")) {
    if (m.IsRoot()) {
      ost_->Write(0., "");
    }
  }
}

template <class M>
void Hydro<M>::DumpTraj(
    M& m, bool dm, const Vars& var, size_t frame, Scal t,
    const GRange<size_t>& layers, const Multi<const FieldCell<Scal>*>& fcvf,
    const Multi<const FieldCell<Scal>*>& fccl,
    const Multi<const FieldCell<MIdx>*>& fcim, const FieldCell<Scal>& fcp,
    const FieldCell<Vect>& fcvel, const FieldCell<Vect>& fcvelm, Scal dt) {
  auto sem = m.GetSem("dumptraj");
  struct {
    std::vector<std::string> names; // color reduce: variable name
    std::vector<Scal> colors; // color reduce: cl
    std::vector<std::vector<Scal>> values; // color reduce: vector
    std::unique_ptr<SA> sphavg; // spherical averages
    using Sph = typename SA::Sph;
    std::vector<Sph> vsph;
  } * ctx(sem);
  auto& names = ctx->names;
  auto& colors = ctx->colors;
  auto& values = ctx->values;
  auto& sphavg = ctx->sphavg;
  auto& vsph = ctx->vsph;
  if (sem("color-calc")) {
    std::map<Scal, std::vector<Scal>> mp; // map color to vector
    Vect gh = m.GetGlobalLength(); // global domain length

    // add scalar name
    auto nma = [&](const std::string nm) { names.push_back(nm); };
    // add vector name
    auto nmav = [&](const std::string nm) {
      names.push_back(nm + "x");
      names.push_back(nm + "y");
      names.push_back(nm + "z");
    };

    // XXX: adhoc, the following order assumed in post: vs,r,x,y,z,...

    // list of vars // TODO: revise
    names.clear();
    nma("vf");
    nma("r");
    nmav("");
    nmav("v");
    nma("p");
    nma("xx");
    nma("xy");
    nma("xz");
    nma("yy");
    nma("yz");
    nma("zz");

    // traverse cells, append to mp
    for (auto c : m.Cells()) {
      for (auto l : layers) {
        auto cl = (*fccl[l])[c];
        if (cl != kClNone) {
          auto& v = mp[cl]; // vector for data
          auto x = m.GetCenter(c); // cell center
          x += Vect((*fcim[l])[c]) * gh; // translation by image vector
          auto w = (*fcvf[l])[c] * m.GetVolume(c); // volume

          size_t i = 0;
          // append scalar value
          auto add = [&v, &i](Scal a) {
            if (i >= v.size()) {
              v.resize(i + 1);
            }
            v[i] += a;
            ++i;
          };
          // append vector value
          auto addv = [&](Vect a) {
            add(a[0]);
            add(a[1]);
            add(a[2]);
          };

          // list of vars, XXX: keep consistent with names
          add(w); // vf,  XXX: adhoc, vf must be first, divided on dump
          add(0.); // r,  XXX: adhoc, r must be second, computed on dump
          addv(x * w); // x
          addv(fcvel[c] * w); // velocity
          add(fcp[c] * w); // pressure
          add(x[0] * x[0] * w); // xx
          add(x[0] * x[1] * w); // xy
          add(x[0] * x[2] * w); // xz
          add(x[1] * x[1] * w); // yy
          add(x[1] * x[2] * w); // yz
          add(x[2] * x[2] * w); // zz
        }
      }
    }
    // copy to vector
    colors.clear();
    values.clear();
    for (auto it : mp) {
      colors.push_back(it.first); // color
      values.push_back(it.second); // vector
    }
    using TS = typename M::template OpCatT<Scal>;
    using TVS = typename M::template OpCatVT<Scal>;
    m.Reduce(std::make_shared<TS>(&colors));
    m.Reduce(std::make_shared<TVS>(&values));
  }
  if (sem("color-post")) {
    if (m.IsRoot()) {
      // root has concatenation of all colors and values
      if (colors.size() != values.size()) {
        throw std::runtime_error(
            "color-reduce: colors.size() != values.size()");
      }

      std::map<Scal, std::vector<Scal>> clmp;
      // reduce to map
      for (size_t k = 0; k < colors.size(); ++k) {
        auto cl = colors[k];
        auto& v = values[k];
        auto& vm = clmp[cl];
        vm.resize(v.size(), 0.);
        for (size_t i = 0; i < v.size(); ++i) {
          vm[i] += v[i];
        }
      }

      // divide by vf
      for (auto& it : clmp) {
        auto& v = it.second;
        Scal vf = v[0]; // XXX: assume vf is first
        Scal pi = M_PI;
        // XXX: assume r is second
        v[1] = std::pow(3. / (4. * pi) * vf, 1. / 3.);
        // divide remaining by vf
        for (size_t i = 2; i < v.size(); ++i) {
          v[i] /= vf;
        }
      }

      colors.clear();
      values.clear();
      for (auto& it : clmp) {
        colors.push_back(it.first);
        values.push_back(it.second);
      }
    }

    using TS = typename M::template OpCatT<Scal>;
    using TVS = typename M::template OpCatVT<Scal>;
    m.Bcast(std::make_shared<TS>(&colors));
    m.Bcast(std::make_shared<TVS>(&values));
  }
  if (sem("sphavg-init")) {
    if (var.Int["enable_shell"]) {
      sphavg.reset(new SA(m, var.Int["dim"]));
    }
  }
  if (sphavg && sem("sphavg-sph")) {
    const Scal shrr = var.Double["shell_rr"]; // shell inner radius relative
                                              // to equivalent radius
    const Scal shr = var.Double["shell_r"]; // shell inner radius absolute
    // shell total radius: rr * req + r
    const Scal shh = var.Double["shell_h"]; // shell thickness relative to h
    auto h = m.GetCellSize();

    vsph.clear();
    for (auto& s : values) {
      // XXX: adhoc, assume vf,r,x,y,z in values
      Vect x(s[2], s[3], s[4]);
      Scal r = s[1] * shrr + shr;
      vsph.emplace_back(x, r, h[0] * shh);
    }
  }
  if (sphavg && sem.Nested("sphavg-update")) {
    sphavg->Update(*fcvf[0], fcvel, fcvelm, dt, fcp, vsph);
  }
  if (sem("color-dump") && dm) {
    if (m.IsRoot()) {
      std::string s = GetDumpName("traj", ".csv", frame);
      std::cout << std::fixed << std::setprecision(8) << "dump"
                << " t=" << t << " to " << s << std::endl;
      std::ofstream o;
      o.open(s);
      o.precision(20);
      // header
      {
        o << "cl";
        for (size_t i = 0; i < names.size(); ++i) {
          o << "," << names[i];
        }
        o << std::endl;
      }
      // content
      for (size_t i = 0; i < colors.size(); ++i) {
        o << colors[i];
        for (auto v : values[i]) {
          o << "," << v;
        }
        o << "\n";
      }
    }
    if (sphavg) {
      if (m.IsRoot()) {
        std::string s = GetDumpName("trajsh", ".csv", frame);
        std::cout << std::fixed << std::setprecision(8) << "dump"
                  << " t=" << t << " to " << s << std::endl;
        std::ofstream o;
        o.open(s);
        o.precision(20);
        // header
        {
          auto nn = sphavg->GetNames();
          o << "cl";
          for (auto n : nn) {
            o << "," << n;
          }
          o << std::endl;
        }
        // content
        auto cl = colors;
        auto av = sphavg->GetAvg();
        if (cl.size() != av.size()) {
          throw std::runtime_error(
              "trajsh: cl.size()=" + std::to_string(cl.size()) +
              " != av.size()=" + std::to_string(av.size()));
        }
        for (size_t i = 0; i < cl.size(); ++i) {
          o << cl[i];
          for (auto& a : av[i].SerOut()) {
            o << "," << a;
          }
          o << "\n";
        }
      }
    }
  }
}

template <class M>
void Hydro<M>::Run() {
  auto sem = m.GetSem("run");

  if (sem.Nested("init")) {
    Init();
  }

  if (var.Int["dumpinit"]) {
    if (sem.Nested()) {
      Dump();
    }
  }

  sem.LoopBegin();

  if (sem("events")) {
    if (events_) {
      events_->Exec(st_.t);
    }
  }
  if (sem("loop-check")) {
    if (st_.t + st_.dt * 0.25 > var.Double["tmax"] ||
        int(st_.step) >= var.Int["max_step"]) {
      sem.LoopBreak();
    } else {
      if (m.IsRoot()) {
        ReportStep();
      }
      m.SeedSample();
    }
  }

  CheckAbort(sem);

  if (sem("updatepar")) {
    if (auto fs = dynamic_cast<FSS*>(fs_.get())) {
      Parse<M>(fs->GetPar(), var);
    } else if (auto fs = dynamic_cast<FSP*>(fs_.get())) {
      Parse<M>(fs->GetPar(), var);
    }
    UpdateAdvectionPar();
    fcvm_ = fs_->GetVelocity();
  }
  if (sem.Nested("mixture")) {
    CalcMixture(as_->GetField());
  }
  if (sem.Nested("stat")) {
    CalcStat();
  }
  if (sem.Nested("fs-start")) {
    fs_->StartStep();
  }
  if (var.Int["enable_fluid"]) {
    if (sem.Nested("fs-iters")) {
      StepFluid();
    }
  }
  if (sem.Nested("fs-finish")) {
    fs_->FinishStep();
  }

  if (var.Int["enable_advection"]) {
    if (sem.Nested("as-steps")) {
      StepAdvection();
    }
    if (sem.Nested("as-post")) {
      as_->PostStep();
    }
    if (sem.Nested("curv")) {
      psm_ = UCurv<M>::CalcCurvPart(layers, as_.get(), psm_par_, fck_, m);
    }
    if (var.Int["enable_bubgen"]) {
      if (sem.Nested("bubgen")) {
        StepBubgen();
      }
    }
  }

  if (sem.Nested("dt")) {
    CalcDt(); // must be after CalcStat to keep dt for moving mesh velocity
  }

  if (sem.Nested()) {
    Dump();
  }

  if (sem("inc")) {
    ++st_.step;
    m.CollectSample("Hydro::Step");
  }

  sem.LoopEnd();
}

template <class M>
void Hydro<M>::ReportStep() {
  std::cout << std::fixed << std::setprecision(8) << "STEP=" << st_.step
            << " t=" << st_.t << " dt=" << st_.dt << " ta=" << as_->GetTime()
            << " dta=" << as_->GetTimeStep() << std::endl;
}

template <class M>
void Hydro<M>::CheckAbort(Sem& sem) {
  if (sem("abort-local")) {
    nabort_ = 0.;
    try {
      CHECKNAN(as_->GetField(), true)
      CHECKNAN(fs_->GetVelocity(), true)
      CHECKNAN(fs_->GetPressure(), true)
      // check abort TODO: revise,move
      for (auto c : m.Cells()) {
        if (fs_->GetVelocity()[c].sqrnorm() > sqr(var.Double["abortvel"])) {
          std::stringstream g;
          g << "abortvel exceeded at x=" << m.GetCenter(c);
          throw std::runtime_error(g.str());
        }
      }
    } catch (const std::runtime_error& e) {
      std::cout << e.what() << std::endl;
      nabort_ += 1.;
    }
    m.Reduce(&nabort_, "sum");
  }

  if (sem("abort-reduce")) {
    if (nabort_ != 0.) {
      if (m.IsRoot()) {
        std::cout << "nabort_ = " << nabort_ << std::endl;
      }
      sem.LoopBreak();
    }
  }
}

template <class M>
void Hydro<M>::StepFluid() {
  auto sem = m.GetSem("iter"); // sem nested
  sem.LoopBegin();
  if (sem.Nested("iter")) {
    fs_->MakeIteration();
  }
  if (sem("reduce")) {
    diff_ = fs_->GetError();
    m.Reduce(&diff_, "max");
  }
  if (sem("report")) {
    ++st_.iter;
    if (m.IsLead()) {
      this->var_mutable.Int["iter"] = st_.iter;
    }
    if (m.IsRoot()) {
      std::cout << std::scientific << std::setprecision(16)
                << ".....iter=" << fs_->GetIter() << ", diff=" << diff_
                << std::endl;
    }
  }
  if (sem("convcheck")) {
    assert(fs_->GetError() <= diff_);
    auto it = fs_->GetIter();
    if ((diff_ < var.Double["tol"] && (int)it >= var.Int["min_iter"]) ||
        (int)it >= var.Int["max_iter"]) {
      sem.LoopBreak();
    }
  }
  // TODO: Suspender loop hangs if (probably) Nested is last
  sem.LoopEnd();
}

template <class M>
void Hydro<M>::StepAdvection() {
  auto sem = m.GetSem("steps"); // sem nested
  sem.LoopBegin();
  if (sem.Nested("start")) {
    as_->StartStep();
  }
  if (sem.Nested("iter")) {
    as_->MakeIteration();
  }
  if (sem.Nested("finish")) {
    as_->FinishStep();
  }
  if (sem("report")) {
    if (m.IsRoot()) {
      std::cout << std::fixed << std::setprecision(8)
                << ".....adv: t=" << as_->GetTime()
                << " dt=" << as_->GetTimeStep() << std::endl;
    }
  }
  if (sem("convcheck")) {
    if (as_->GetTime() >= fs_->GetTime() - 0.5 * as_->GetTimeStep()) {
      sem.LoopBreak();
    }
  }
  sem.LoopEnd();
}

template <class M>
void Hydro<M>::StepBubgen() {
  auto sem = m.GetSem("bubgen");
  Scal t0 = var.Double["bubgen_t0"];
  Scal tper = var.Double["bubgen_per"];
  bool bg = (st_.t > t0 && st_.t - bgt_ >= tper);
  if (bg) {
    if (sem("as-bubgen-init")) {
      if (!bgf_) {
        Vars vr;
        vr.String.Set("init_vf", "list");
        vr.String.Set("list_path", var.String["bubgen_path"]);
        vr.Int.Set("dim", var.Int["dim"]);
        vr.Int.Set("list_ls", var.Int["list_ls"]);
        bgf_ = CreateInitU<M>(vr, m.IsRoot());
      }
      fc_vf_.Reinit(m, 0);
      bgf_(fc_vf_, m);
      m.Comm(&fc_vf_);
    }
    if (sem("as-bubgen-apply")) {
      bgt_ = st_.t;
      if (auto as = dynamic_cast<ASVM*>(as_.get())) {
        auto& u = const_cast<FieldCell<Scal>&>(*as->GetFieldM()[0]);
        auto& cl = const_cast<FieldCell<Scal>&>(*as->GetColor()[0]);
        for (auto c : m.AllCells()) {
          if (fc_vf_[c] > 0) {
            u[c] = std::max(u[c], fc_vf_[c]);
            cl[c] = 1.;
          }
        }
      }
      if (auto as = dynamic_cast<ASV*>(as_.get())) {
        auto& u = const_cast<FieldCell<Scal>&>(as->GetField());
        for (auto c : m.AllCells()) {
          if (fc_vf_[c] > 0) {
            u[c] = std::max(u[c], fc_vf_[c]);
          }
        }
      }
    }
  }
}

// XXX: [fabianw@mavt.ethz.ch; 2019-11-17] debug
template bool IsNan<double, GIdx<0>>(const FieldCell<double>&);
template bool IsNan<GVect<double, 3>, GIdx<0>>(
    const FieldCell<GVect<double, 3>>&);
template bool IsNan<double>(double);
template bool IsNan<double, 3>(const GVect<double, 3>&);

template <class T, class Idx>
T MySum(const GField<T, Idx>& u) {
  T sum = T(0);
  for (auto i : u.GetRange()) {
    sum += u[i];
  }
  return sum;
}

template double MySum<double, GIdx<0>>(const FieldCell<double>&);
template GVect<double, 3> MySum<GVect<double, 3>, GIdx<0>>(
    const FieldCell<GVect<double, 3>>&);

template <class T, class Idx>
void dumpField(const GField<T, Idx>& u) {
  std::ofstream out("data.bin", std::ios::binary);
  const T* src = (T*)u.data();
  for (size_t i = 0; i < u.size(); ++i) {
    out.write((const char*)src++, sizeof(T));
  }
  out.close();
}
template void dumpField<double, GIdx<0>>(const FieldCell<double>&);
template void dumpField<GVect<double, 3>, GIdx<0>>(
    const FieldCell<GVect<double, 3>>&);
