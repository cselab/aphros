#include <memory>
#include <cmath>

#include "geom/mesh.h"
#include "solver.h"


namespace solver {

template <class M_>
struct UNormal<M_>::Imp {
  static constexpr size_t dim = M::dim;

  static auto Maxmod(Scal a, Scal b) -> Scal {
    return std::abs(b) < std::abs(a) ? a : b;
  }

  // Computes normal by gradient.
  // uc: volume fraction
  // mfc: boundary conditions for volume fraction
  // Output: modified in cells with msk=1
  // fcn: normal [s] 
  static void CalcNormalGrad(M& m, const FieldCell<Scal>& uc,
                             const MapFace<std::shared_ptr<CondFace>>& mfc,
                              FieldCell<Vect>& fcn) {
    auto uf = Interpolate(uc, mfc, m);
    auto gc = Gradient(uf, m);
    for (auto c : m.AllCells()) {
      Vect g = gc[c];
      fcn[c] = g;
    }
  }
  // Computes normal by Young's scheme (interpolation of gradient from nodes).
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // Output: modified in cells with fci=1, resized to m
  // fcn: normal with norm1()=1, antigradient of fcu [s] 
  // XXX: uses static variables, not suspendable
  // TODO: check non-uniform mesh
  static void CalcNormalYoung(M& m, const FieldCell<Scal>& fcu, 
                              const FieldCell<bool>& fci,
                              FieldCell<Vect>& fcn) {
    static FieldNode<Vect> g;  // gradient
    static FieldNode<Vect> l;  // step from cell to node
    g.Reinit(m, Vect(0));
    l.Reinit(m, Vect(0));
    // values from cells to neighbour nodes
    for (auto c : m.AllCells()) {
      Vect xc = m.GetCenter(c);
      for (size_t q = 0; q < m.GetNumNeighbourNodes(c); ++q) {
        IdxNode n = m.GetNeighbourNode(c, q);
        Vect xn = m.GetNode(n);
        for (size_t d = 0; d < dim; ++d) {
          g[n][d] += (xc[d] - xn[d] > 0. ? 1. : -1.) * fcu[c];
          l[n][d] += std::abs(xc[d] - xn[d]);
        }
      } 
    } 
    // gradient on nodes
    for (auto n : m.SuNodes()) {
      g[n] /= l[n];
    }

    // gradient on cells
    fcn.Reinit(m);
    for (auto c : m.SuCells()) {
      if (fci[c]) {
        // sum over neighbour nodes
        auto& v = fcn[c];
        v = Vect(0);
        for (size_t q = 0; q < m.GetNumNeighbourNodes(c); ++q) {
          IdxNode n = m.GetNeighbourNode(c, q);
          v += g[n];
        }
        // normalize
        v /= -v.norm1();
      }
    }
  }
  // CalcNormalYoung: optimized implementation
  static void CalcNormalYoung1(M& m, const FieldCell<Scal>& fcu, 
                               const FieldCell<bool>& fci,
                               FieldCell<Vect>& fcn) {
    using MIdx = typename M::MIdx;
    auto ic = m.GetIndexCells();
    auto bc = m.GetSuBlockCells();
    MIdx s = ic.GetSize();
    const size_t nx = s[0];
    const size_t ny = s[1];
    // offset
    const size_t fx = 1;
    const size_t fy = nx;
    const size_t fz = ny * nx;

    // index range
    const MIdx wb = bc.GetBegin() - ic.GetBegin();
    const MIdx we = bc.GetEnd() - ic.GetBegin();
    const size_t xb = wb[0], yb = wb[1], zb = wb[2];
    const size_t xe = we[0], ye = we[1], ze = we[2];

    fcn.Reinit(m);

    const Vect h = m.GetCellSize();

    const Scal* pu = fcu.data();
    Vect* pn = fcn.data();
    const bool* pi = fci.data();
    for (size_t z = zb; z < ze; ++z) {
      for (size_t y = yb; y < ye; ++y) {
        for (size_t x = xb; x < xe; ++x) {
          size_t i = (z * ny + y) * nx + x;
          if (!pi[i]) {
            continue;
          }
          auto q = [i,fy,fz,pu](int dx, int dy, int dz) {
            size_t ii = i + dx * fx + dy * fy + dz * fz;
            return pu[ii];
          };
          // generated by gen/normal.py
          pn[i][0] = (1.0/32.0)*(-q(-1,-1,-1) - 2*q(-1,-1,0) -
          q(-1,-1,1) - 2*q(-1,0,-1) - 4*q(-1,0,0) - 2*q(-1,0,1) -
          q(-1,1,-1) - 2*q(-1,1,0) - q(-1,1,1) + q(1,-1,-1) +
          2*q(1,-1,0) + q(1,-1,1) + 2*q(1,0,-1) + 4*q(1,0,0) +
          2*q(1,0,1) + q(1,1,-1) + 2*q(1,1,0) + q(1,1,1))/h[0];
          pn[i][1] = (1.0/32.0)*(-q(-1,-1,-1) - 2*q(-1,-1,0) -
          q(-1,-1,1) + q(-1,1,-1) + 2*q(-1,1,0) + q(-1,1,1) -
          2*q(0,-1,-1) - 4*q(0,-1,0) - 2*q(0,-1,1) + 2*q(0,1,-1) +
          4*q(0,1,0) + 2*q(0,1,1) - q(1,-1,-1) - 2*q(1,-1,0) -
          q(1,-1,1) + q(1,1,-1) + 2*q(1,1,0) + q(1,1,1))/h[1];
          pn[i][2] = (1.0/32.0)*(-q(-1,-1,-1) + q(-1,-1,1) -
          2*q(-1,0,-1) + 2*q(-1,0,1) - q(-1,1,-1) + q(-1,1,1) -
          2*q(0,-1,-1) + 2*q(0,-1,1) - 4*q(0,0,-1) + 4*q(0,0,1) -
          2*q(0,1,-1) + 2*q(0,1,1) - q(1,-1,-1) + q(1,-1,1) -
          2*q(1,0,-1) + 2*q(1,0,1) - q(1,1,-1) + q(1,1,1))/h[2];

          pn[i] /= -pn[i].norm1();
        }
      }
    }
  }
  // Computes normal and curvature from height functions.
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // edim: effective dimension
  // ow: 1: force overwrite, 0: update only if gives steeper profile
  // Output: modified in cells with fci=1, resized to m
  // fcn: normal, antigradient of fcu, if gives steeper profile or ow=1 [s] 
  // fck: curvature [s] 
  static void CalcNormalHeight(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      size_t edim, bool ow, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
    using MIdx = typename M::MIdx;
    using Dir = typename M::Dir;
    auto& bc = m.GetIndexCells();

    fcn.Reinit(m); // XXX
    fck.Reinit(m);

    for (auto c : m.SuCells()) {
      if (!fci[c]) {
        continue;
      }
      Vect bn; // best normal
      Scal bhx = 0., bhy = 0.; // best first derivative
      Scal bk = 0.; // best curvature[k]
      Dir bd = Dir::i;  // best direction
      bool fst = true; // first
      std::vector<Dir> dd; // direction of plane normal
      if (edim == 2) {
        dd = {Dir::i, Dir::j};
      } else {
        dd = {Dir::i, Dir::j, Dir::k};
      }
      for (Dir dn : dd) {
        // directions of plane tangents ([d]irection [t]angents)
        Dir dtx((size_t(dn) + 1) % dim); 
        Dir dty((size_t(dn) + 2) % dim); 

        MIdx w = bc.GetMIdx(c);

        // offset in normal direction
        MIdx on = MIdx(dn);
        // offset in dtx,dty
        MIdx otx = MIdx(dtx);
        MIdx oty = MIdx(dty);
        // mesh step
        const Scal lx = m.GetCellSize()[size_t(dtx)];
        const Scal ly = m.GetCellSize()[size_t(dty)];
        const Scal ln = m.GetCellSize()[size_t(dn)];

        // Evaluates height function
        // o: offset from w
        auto hh = [&](MIdx o) -> Scal {
          return 
            (fcu[bc.GetIdx(w + o - on)] + 
            fcu[bc.GetIdx(w + o)] + 
            fcu[bc.GetIdx(w + o + on)]) * ln;
        };

        // height function
        const Scal h = hh(MIdx(0));
        const Scal hxm = hh(-otx);
        const Scal hxp = hh(otx);
        const Scal hym = hh(-oty);
        const Scal hyp = hh(oty);
        // corners: hxy
        const Scal hmm = hh(-otx - oty); 
        const Scal hmp = hh(-otx + oty);
        const Scal hpm = hh(otx - oty);
        const Scal hpp = hh(otx + oty);

        // first derivative (slope)
        Scal hx = (hxp - hxm) / (2. * lx);  // centered
        Scal hy = (hyp - hym) / (2. * ly); 
        // sign: +1 if u increases in dn
        Scal sg = 
            (fcu[bc.GetIdx(w + on)] - fcu[bc.GetIdx(w - on)] > 0. ? 1. : -1.);
        // second derivative 
        Scal hxx = (hxp - 2. * h + hxm) / (lx * lx);
        Scal hyy = (hyp - 2. * h + hym) / (ly * ly);
        Scal hxy = ((hpp - hmp) - (hpm - hmm)) / (4. * lx * ly);
        // curvature
        Scal k = (2. * hx * hy * hxy 
            -(sqr(hy) + 1.) * hxx -(sqr(hx) + 1.) * hyy) / 
            std::pow(sqr(hx) + sqr(hy) + 1., 3. / 2.);
        // outer normal
        Vect n;
        n[size_t(dtx)] = -hx;
        n[size_t(dty)] = -hy;
        n[size_t(dn)] = -sg;
        // select best with minimal slope
        if (fst || 
            std::abs(hx) + std::abs(hy) < std::abs(bhx) + std::abs(bhy)) {
          bn = n;
          bhx = hx;
          bhy = hy;
          bk = k;
          bd = dn;
          fst = false;
        } 
      }
      bn /= bn.norm1(); // normalize

      // update if ow=1 or gives steeper profile in plane dn
      if (ow || std::abs(bn[size_t(bd)]) < std::abs(fcn[c][size_t(bd)])) {
        fcn[c] = bn;
      }

      // curvature
      fck[c] = bk;
    }
  }
  template <class Q>
  static void F(Q& qn, Scal& gxm, Scal& gxp, Scal& gym, Scal& gyp, Scal& sg,
                Scal& gc, Scal& gmm, Scal& gmp, Scal& gpm, Scal& gpp) {
    auto g = [&qn](int dx, int dy) {
      return qn(dx,dy,1) + qn(dx,dy,0) + qn(dx,dy,-1);
    };
    gxm = g(-1,0);
    gxp = g(1,0);
    gym = g(0,-1);
    gyp = g(0,1);
    sg = (qn(0,0,1) - qn(0,0,-1) > 0. ? 1. : -1);
    gc = g(0,0);
    gmm = g(-1,-1);
    gmp = g(-1,1);
    gpm = g(1,-1);
    gpp = g(1,1);
  }
  // CalcNormalHeight: optimized implementation
  static void CalcNormalHeight1(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      size_t edim, bool ow, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
    using MIdx = typename M::MIdx;
    auto ic = m.GetIndexCells();
    auto bc = m.GetSuBlockCells();
    MIdx s = ic.GetSize();
    const size_t nx = s[0];
    const size_t ny = s[1];
    // offset
    const size_t fx = 1;
    const size_t fy = nx;
    const size_t fz = ny * nx;

    // index range
    const MIdx wb = bc.GetBegin() - ic.GetBegin();
    const MIdx we = bc.GetEnd() - ic.GetBegin();
    const size_t xb = wb[0], yb = wb[1], zb = wb[2];
    const size_t xe = we[0], ye = we[1], ze = we[2];

    fcn.Reinit(m);
    fck.Reinit(m);

    const Vect h = m.GetCellSize();

    const Scal* pu = fcu.data();
    Vect* pn = fcn.data();
    Scal* pk = fck.data();
    const bool* pi = fci.data();
    for (size_t z = zb; z < ze; ++z) {
      for (size_t y = yb; y < ye; ++y) {
        for (size_t x = xb; x < xe; ++x) {
          size_t i = (z * ny + y) * nx + x;
          if (!pi[i]) {
            continue;
          }
          auto q = [i,fy,fz,pu](int dx, int dy, int dz) {
            size_t ii = i + dx * fx + dy * fy + dz * fz;
            return pu[ii];
          };
          auto qx = [&q](int dx, int dy, int dz) {
            return q(dz, dx, dy);
          };
          auto qy = [&q](int dx, int dy, int dz) {
            return q(dy, dz, dx);
          };
          auto qz = [&q](int dx, int dy, int dz) {
            return q(dx, dy, dz);
          };

          Vect bn(0); // best normal
          size_t bd = 0;  // best direction
          Scal bk = 0;    // best curvature
          std::vector<size_t> dd; // direction of plane normal
          if (edim == 2) {
            dd = {0, 1};
          } else {
            dd = {0, 1, 2};
          }
          for (size_t dn : dd) {
            size_t dx = (dn + 1) % dim;
            size_t dy = (dn + 2) % dim;

            // height function
            Scal gxm, gxp, gym, gyp;
            Scal gc, gmm, gmp, gpm, gpp;
            // sign: +1 if u increases in dn
            Scal sg;
            switch (dn) {
              case 0: { // dx:1 , dy:2
                F(qx, gxm, gxp, gym, gyp, sg, gc, gmm, gmp, gpm, gpp); break;
              }
              case 1: { // dx:2 , dy:0
                F(qy, gxm, gxp, gym, gyp, sg, gc, gmm, gmp, gpm, gpp); break;
              }
              default: { // dx:0 , dy:1
                F(qz, gxm, gxp, gym, gyp, sg, gc, gmm, gmp, gpm, gpp); break;
              }
            }

            Scal ln = h[dn];
            Scal lx = h[dx];
            Scal ly = h[dy];
            // first derivative (slope)
            Scal gx = (gxp - gxm) * ln / (2. * lx);  // centered
            Scal gy = (gyp - gym) * ln / (2. * ly);
            // outer normal
            Vect n;
            n[dx] = -gx;
            n[dy] = -gy;
            n[dn] = -sg;
            n /= n.norm1();
            // select best with minimal slope
            if (std::abs(n[dn]) > std::abs(bn[bd])) {
              bn = n;
              bd = dn;
              // second derivative 
              Scal gxx = (gxp - 2. * gc + gxm) * ln / (lx * lx);
              Scal gyy = (gyp - 2. * gc + gym) * ln / (ly * ly);
              Scal gxy = ((gpp - gmp) - (gpm - gmm)) / (4. * lx * ly);
              // curvature
              bk = (2. * gx * gy * gxy
                  -(sqr(gy) + 1.) * gxx -(sqr(gx) + 1.) * gyy) /
                  std::pow(sqr(gx) + sqr(gy) + 1., 3. / 2.);
            }
          }

          // update if ow=1 or gives steeper profile in plane dn
          if (ow || std::abs(bn[bd]) < std::abs(pn[i][bd])) {
            pn[i] = bn;
          }
          // curvature
          pk[i] = bk;
        }
      }
    }
  }
  // Computes normal by combined Young's scheme and height-functions
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // edim: effective dimension
  // Output: set to NaN if fci=0
  // fcn: normal with norm1()=1, antigradient of fcu [s] 
  // fck: curvature
  static void CalcNormal(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      size_t edim, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
    fcn.Reinit(m, Vect(GetNan<Scal>()));
    fck.Reinit(m, GetNan<Scal>());
    CalcNormalYoung1(m,fcu, fci, fcn);
    CalcNormalHeight1(m, fcu, fci, edim, false, fcn, fck);
  }
};

template <class M_>
void UNormal<M_>::CalcNormal(
    M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
    size_t edim, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
  Imp::CalcNormal(m, fcu, fci, edim, fcn, fck);
}

template <class M_>
void UNormal<M_>::CalcNormalYoung(
    M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
    FieldCell<Vect>& fcn) {
  Imp::CalcNormalYoung1(m, fcu, fci, fcn);
}

} // namespace solver
