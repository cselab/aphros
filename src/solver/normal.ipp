#include <memory>
#include <cmath>

#include "geom/mesh.h"
#include "solver.h"


namespace solver {

template <class M_>
struct UNormal<M_>::Imp {
  static constexpr size_t dim = M::dim;

  static auto Maxmod(Scal a, Scal b) -> Scal {
    return std::abs(b) < std::abs(a) ? a : b;
  }

  // Computes normal by gradient.
  // uc: volume fraction
  // mfc: boundary conditions for volume fraction
  // Output: modified in cells with msk=1
  // fcn: normal [s] 
  static void CalcNormalGrad(M& m, const FieldCell<Scal>& uc,
                             const MapFace<std::shared_ptr<CondFace>>& mfc,
                              FieldCell<Vect>& fcn) {
    auto uf = Interpolate(uc, mfc, m);
    auto gc = Gradient(uf, m);
    for (auto c : m.AllCells()) {
      Vect g = gc[c];
      fcn[c] = g;
    }
  }
  // Computes normal by Young's scheme (interpolation of gradient from nodes).
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // Output: modified in cells with fci=1, resized to m
  // fcn: normal with norm1()=1, antigradient of fcu [s] 
  // XXX: uses static variables, not suspendable
  // TODO: check non-uniform mesh
  static void CalcNormalYoung(M& m, const FieldCell<Scal>& fcu, 
                              const FieldCell<bool>& fci,
                              FieldCell<Vect>& fcn) {
    static FieldNode<Vect> g;  // gradient
    static FieldNode<Vect> l;  // step from cell to node
    g.Reinit(m, Vect(0));
    l.Reinit(m, Vect(0));
    // values from cells to neighbour nodes
    for (auto c : m.AllCells()) {
      Vect xc = m.GetCenter(c);
      for (size_t q = 0; q < m.GetNumNeighbourNodes(c); ++q) {
        IdxNode n = m.GetNeighbourNode(c, q);
        Vect xn = m.GetNode(n);
        for (size_t d = 0; d < dim; ++d) {
          g[n][d] += (xc[d] - xn[d] > 0. ? 1. : -1.) * fcu[c];
          l[n][d] += std::abs(xc[d] - xn[d]);
        }
      } 
    } 
    // gradient on nodes
    for (auto n : m.SuNodes()) {
      g[n] /= l[n];
    }

    // gradient on cells
    fcn.Reinit(m);
    for (auto c : m.SuCells()) {
      if (fci[c]) {
        // sum over neighbour nodes
        auto& v = fcn[c];
        v = Vect(0);
        for (size_t q = 0; q < m.GetNumNeighbourNodes(c); ++q) {
          IdxNode n = m.GetNeighbourNode(c, q);
          v += g[n];
        }
        // normalize
        v /= -v.norm1();
      }
    }
  }
  // CalcNormalYoung: optimized implementation
  static void CalcNormalYoung2(M& m, const FieldCell<Scal>& fcu, 
                               const FieldCell<bool>& fci,
                               FieldCell<Vect>& fcn) {
    using MIdx = typename M::MIdx;
    auto ic = m.GetIndexCells();
    auto bc = m.GetSuBlockCells();
    MIdx s = ic.GetSize();
    const size_t nx = s[0];
    const size_t ny = s[1];
    // offset
    const size_t fx = 1;
    const size_t fy = nx;
    const size_t fz = ny * nx;

    // index range
    const MIdx wb = bc.GetBegin() - ic.GetBegin();
    const MIdx we = bc.GetEnd() - ic.GetBegin();
    const size_t xb = wb[0], yb = wb[1], zb = wb[2];
    const size_t xe = we[0], ye = we[1], ze = we[2];

    fcn.Reinit(m);

    const Vect h = m.GetCellSize();

    const Scal* pu = fcu.data();
    Vect* pn = fcn.data();
    const bool* pi = fci.data();
    for (size_t z = zb; z < ze; ++z) {
      for (size_t y = yb; y < ye; ++y) {
        for (size_t x = xb; x < xe; ++x) {
          size_t i = (z * ny + y) * nx + x;
          if (!pi[i]) {
            continue;
          }
          auto q = [i,fx,fy,fz,pu](int dx, int dy, int dz) {
            size_t ii = i;
            if (dx == 1)  ii += fx;
            if (dx == -1) ii -= fx;
            if (dy == 1)  ii += fy;
            if (dy == -1) ii -= fy;
            if (dz == 1)  ii += fz;
            if (dz == -1) ii -= fz;
            return pu[ii];
          };
          // generated by gen/normal.py
          pn[i][0] = (1.0/32.0)*(-q(-1,-1,-1) - 2*q(-1,-1,0) -
          q(-1,-1,1) - 2*q(-1,0,-1) - 4*q(-1,0,0) - 2*q(-1,0,1) -
          q(-1,1,-1) - 2*q(-1,1,0) - q(-1,1,1) + q(1,-1,-1) +
          2*q(1,-1,0) + q(1,-1,1) + 2*q(1,0,-1) + 4*q(1,0,0) +
          2*q(1,0,1) + q(1,1,-1) + 2*q(1,1,0) + q(1,1,1))/h[0];
          pn[i][1] = (1.0/32.0)*(-q(-1,-1,-1) - 2*q(-1,-1,0) -
          q(-1,-1,1) + q(-1,1,-1) + 2*q(-1,1,0) + q(-1,1,1) -
          2*q(0,-1,-1) - 4*q(0,-1,0) - 2*q(0,-1,1) + 2*q(0,1,-1) +
          4*q(0,1,0) + 2*q(0,1,1) - q(1,-1,-1) - 2*q(1,-1,0) -
          q(1,-1,1) + q(1,1,-1) + 2*q(1,1,0) + q(1,1,1))/h[1];
          pn[i][2] = (1.0/32.0)*(-q(-1,-1,-1) + q(-1,-1,1) -
          2*q(-1,0,-1) + 2*q(-1,0,1) - q(-1,1,-1) + q(-1,1,1) -
          2*q(0,-1,-1) + 2*q(0,-1,1) - 4*q(0,0,-1) + 4*q(0,0,1) -
          2*q(0,1,-1) + 2*q(0,1,1) - q(1,-1,-1) + q(1,-1,1) -
          2*q(1,0,-1) + 2*q(1,0,1) - q(1,1,-1) + q(1,1,1))/h[2];

          pn[i] /= -pn[i].norm1();
        }
      }
    }
  }
  // Computes normal and curvature from height functions.
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // edim: effective dimension
  // ow: 1: force overwrite, 0: update only if gives steeper profile
  // Output: modified in cells with fci=1, resized to m
  // fcn: normal, antigradient of fcu, if gives steeper profile or ow=1 [s] 
  // fck: curvature [s] 
  static void CalcNormalHeight(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      size_t edim, bool ow, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
    using MIdx = typename M::MIdx;
    using Dir = typename M::Dir;
    auto& bc = m.GetIndexCells();

    fcn.Reinit(m); // XXX
    fck.Reinit(m);

    for (auto c : m.SuCells()) {
      if (!fci[c]) {
        continue;
      }
      Vect bn; // best normal
      Scal bhx = 0., bhy = 0.; // best first derivative
      Scal bk = 0.; // best curvature[k]
      Dir bd = Dir::i;  // best direction
      bool fst = true; // first
      std::vector<Dir> dd; // direction of plane normal
      if (edim == 2) {
        dd = {Dir::i, Dir::j};
      } else {
        dd = {Dir::i, Dir::j, Dir::k};
      }
      for (Dir dn : dd) {
        // directions of plane tangents ([d]irection [t]angents)
        Dir dtx((size_t(dn) + 1) % dim); 
        Dir dty((size_t(dn) + 2) % dim); 

        MIdx w = bc.GetMIdx(c);

        // offset in normal direction
        MIdx on = MIdx(dn);
        // offset in dtx,dty
        MIdx otx = MIdx(dtx);
        MIdx oty = MIdx(dty);
        // mesh step
        const Scal lx = m.GetCellSize()[size_t(dtx)];
        const Scal ly = m.GetCellSize()[size_t(dty)];
        const Scal ln = m.GetCellSize()[size_t(dn)];

        // Evaluates height function
        // o: offset from w
        auto hh = [&](MIdx o) -> Scal {
          return 
            (fcu[bc.GetIdx(w + o - on)] + 
            fcu[bc.GetIdx(w + o)] + 
            fcu[bc.GetIdx(w + o + on)]) * ln;
        };

        // height function
        const Scal h = hh(MIdx(0));
        const Scal hxm = hh(-otx);
        const Scal hxp = hh(otx);
        const Scal hym = hh(-oty);
        const Scal hyp = hh(oty);
        // corners: hxy
        const Scal hmm = hh(-otx - oty); 
        const Scal hmp = hh(-otx + oty);
        const Scal hpm = hh(otx - oty);
        const Scal hpp = hh(otx + oty);

        // first derivative (slope)
        Scal hx = (hxp - hxm) / (2. * lx);  // centered
        Scal hy = (hyp - hym) / (2. * ly); 
        // sign: +1 if u increases in dn
        Scal sg = 
            (fcu[bc.GetIdx(w + on)] - fcu[bc.GetIdx(w - on)] > 0. ? 1. : -1.);
        // second derivative 
        Scal hxx = (hxp - 2. * h + hxm) / (lx * lx);
        Scal hyy = (hyp - 2. * h + hym) / (ly * ly);
        Scal hxy = ((hpp - hmp) - (hpm - hmm)) / (4. * lx * ly);
        // curvature
        Scal k = (2. * hx * hy * hxy 
            -(sqr(hy) + 1.) * hxx -(sqr(hx) + 1.) * hyy) / 
            std::pow(sqr(hx) + sqr(hy) + 1., 3. / 2.);
        // outer normal
        Vect n;
        n[size_t(dtx)] = -hx;
        n[size_t(dty)] = -hy;
        n[size_t(dn)] = -sg;
        // select best with minimal slope
        if (fst || 
            std::abs(hx) + std::abs(hy) < std::abs(bhx) + std::abs(bhy)) {
          bn = n;
          bhx = hx;
          bhy = hy;
          bk = k;
          bd = dn;
          fst = false;
        } 
      }
      bn /= bn.norm1(); // normalize

      // update if ow=1 or gives steeper profile in plane dn
      if (ow || std::abs(bn[size_t(bd)]) < std::abs(fcn[c][size_t(bd)])) {
        fcn[c] = bn;
      }

      // curvature
      fck[c] = bk;
    }
  }
  // CalcNormalHeight: optimized implementation
  static void CalcNormalHeight2(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      size_t edim, bool ow, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
    using MIdx = typename M::MIdx;
    auto ic = m.GetIndexCells();
    auto bc = m.GetSuBlockCells();
    MIdx s = ic.GetSize();
    const size_t nx = s[0];
    const size_t ny = s[1];
    // offset
    const size_t fx = 1;
    const size_t fy = nx;
    const size_t fz = ny * nx;

    // index range
    const MIdx wb = bc.GetBegin() - ic.GetBegin();
    const MIdx we = bc.GetEnd() - ic.GetBegin();
    const size_t xb = wb[0], yb = wb[1], zb = wb[2];
    const size_t xe = we[0], ye = we[1], ze = we[2];

    (void) edim;
    (void) ow;
    fcn.Reinit(m);
    fck.Reinit(m);

    const Vect h = m.GetCellSize();

    const Scal* pu = fcu.data();
    Vect* pn = fcn.data();
    const bool* pi = fci.data();
    for (size_t z = zb; z < ze; ++z) {
      for (size_t y = yb; y < ye; ++y) {
        for (size_t x = xb; x < xe; ++x) {
          size_t i = (z * ny + y) * nx + x;
          if (!pi[i]) {
            continue;
          }
          /*
          auto q = [i,fx,fy,fz,pu](int dx, int dy, int dz) {
            size_t ii = i;
            if (dx == 1)  ii += fx;
            if (dx == -1) ii -= fx;
            if (dy == 1)  ii += fy;
            if (dy == -1) ii -= fy;
            if (dz == 1)  ii += fz;
            if (dz == -1) ii -= fz;
            return pu[ii];
          };
          */
          auto qw = [i,fx,fy,fz,pu](MIdx w) {
            size_t ii = i;
            if (w[0] == 1)  ii += fx;
            if (w[0] == -1) ii -= fx;
            if (w[1] == 1)  ii += fy;
            if (w[1] == -1) ii -= fy;
            if (w[2] == 1)  ii += fz;
            if (w[2] == -1) ii -= fz;
            return pu[ii];
          };

          Vect bn; // best normal
          Scal bgx = 0., bgy = 0.; // best first derivative
          size_t bd = 0;  // best direction
          bool fst = true; // first
          std::vector<size_t> dd; // direction of plane normal
          if (edim == 2) {
            dd = {0, 1};
          } else {
            dd = {0, 1, 2};
          }
          for (size_t dn : dd) {
            size_t dx = (dn + 1) % dim;
            size_t dy = (dn + 2) % dim;

            MIdx wn(0), wx(0), wy(0);
            wn[dn] = 1;
            wx[dx] = 1;
            wy[dy] = 1;

            // height function [g]
            const Scal gxm = (qw(wn-wx) + qw(-wx) + qw(-wn-wx));
            const Scal gxp = (qw(wn+wx) + qw(wx) + qw(-wn+wx));
            const Scal gym = (qw(wn-wy) + qw(-wy) + qw(-wn-wy));
            const Scal gyp = (qw(wn+wy) + qw(wy) + qw(-wn+wy));

            // first derivative (slope)
            Scal gx = (gxp - gxm) * h[dn] / (2. * h[dx]);  // centered
            Scal gy = (gyp - gym) * h[dn] / (2. * h[dy]);
            // sign: +1 if u increases in dn
            Scal sg = (qw(wn) - qw(-wn) > 0. ? 1. : -1.);
            // outer normal
            Vect n;
            n[dx] = -gx;
            n[dy] = -gy;
            n[dn] = -sg;
            // select best with minimal slope
            if (fst ||
                std::abs(gx) + std::abs(gy) < std::abs(bgx) + std::abs(bgy)) {
              bn = n;
              bgx = gx;
              bgy = gy;
              bd = dn;
              fst = false;
            }
          }
          bn /= bn.norm1(); // normalize

          // update if ow=1 or gives steeper profile in plane dn
          if (ow || std::abs(bn[bd]) < std::abs(pn[i][bd])) {
            pn[i] = bn;
          }
        }
      }
    }
  }
  // Computes normal by combined Young's scheme and height-functions
  // fcu: volume fraction
  // fci: interface mask (1: contains interface)
  // edim: effective dimension
  // Output: set to NaN if fci=0
  // fcn: normal with norm1()=1, antigradient of fcu [s] 
  // fck: curvature
  static void CalcNormal(
      M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
      size_t edim, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
    fcn.Reinit(m, Vect(GetNan<Scal>()));
    fck.Reinit(m, GetNan<Scal>());
    CalcNormalYoung2(m,fcu, fci, fcn);
    CalcNormalHeight(m, fcu, fci, edim, false, fcn, fck);
  }
};

template <class M_>
void UNormal<M_>::CalcNormal(
    M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
    size_t edim, FieldCell<Vect>& fcn, FieldCell<Scal>& fck) {
  Imp::CalcNormal(m, fcu, fci, edim, fcn, fck);
}

template <class M_>
void UNormal<M_>::CalcNormalYoung(
    M& m, const FieldCell<Scal>& fcu, const FieldCell<bool>& fci,
    FieldCell<Vect>& fcn) {
  Imp::CalcNormalYoung2(m, fcu, fci, fcn);
}

} // namespace solver
