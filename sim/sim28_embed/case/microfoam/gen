#!/usr/bin/env python

import aphros
import os
import numpy as np
import itertools
import sys

def Abort(msg):
    sys.stderr.write(str(msg) + '\n')
    exit(1)

def ExpPar():
    # SI units
    # Vecchiolla2018, Figure 2
    mu = 1.25e-3
    sigma = 35.2e-3
    volrate_lh = 12e-3 # litre/hour
    volrate = volrate_lh / 3600. / 1e3
    thickness = 60e-6
    height_narrow = 75e-6
    inlet_area = height_narrow * thickness
    inlet_vel = volrate / inlet_area
    Ca = mu * inlet_vel / sigma
    rho = 1260
    Re = height_narrow * inlet_vel * rho / mu
    print("Ca={:.5g}, Re={:.5g}, inlet_vel={:.5g}".format(Ca, Re, inlet_vel))
    # Ca=0.026305, Re=56, inlet_vel=0.74074


def GetRandomCluster(xlim, ylim, zlim, r, gap__r=2., num_tries=10000):
    '''
    Generates random cloud of spheres.
    xlim,ylim,zlim: array, (3)
        Bounding box, limits in each direction.
    r: float
        Radius of spheres.
    gap__r: float
        Minimal distance between surfaces of spheres relative to `r`.
    '''
    np.random.seed(0)
    gap = r * gap__r
    xx = np.array([])
    yy = np.array([])
    zz = np.array([])
    rr = np.array([])
    c = 0
    while True:
        x = np.clip(np.random.uniform(xlim[0] + r, xlim[1] - r), *xlim)
        y = np.clip(np.random.uniform(ylim[0] + r, ylim[1] - r), *ylim)
        z = np.clip(np.random.uniform(zlim[0] + r, zlim[1] - r), *zlim)
        dm = None  # minimal distance to other bubbles
        if len(xx) == 0 or \
                ((xx - x) ** 2 + (yy - y) ** 2 + (zz - z) ** 2).min() >= \
                (2 * r + gap) ** 2:
            xx = np.append(xx, x)
            yy = np.append(yy, y)
            zz = np.append(zz, z)
            rr = np.append(rr, r)
            c = 0
        else:
            c += 1
            if c > num_tries:
                break
    return np.array((xx, yy, zz, rr))

def GetRegularCluster(xlim, ylim, zlim, r, gap__r=2.):
    '''
    Generates regular lattice of spheres.
    xlim,ylim,zlim: array, (3)
        Bounding box, limits in each direction.
    r: float
        Radius of spheres.
    gap__r: float
        Minimal distance between surfaces of speres relative to `r`.
    '''
    shift = 2 * r + gap__r * r
    nx = max(1, np.ceil((xlim[1] - xlim[0]) / shift))
    ny = max(1, np.ceil((ylim[1] - ylim[0]) / shift))
    nz = max(1, np.ceil((zlim[1] - zlim[0]) / shift))
    m = np.mgrid[:nx,:ny,:nz]
    xx = m[0] * shift
    yy = m[1] * shift
    zz = m[2] * shift
    xx = xx.flatten()
    yy = yy.flatten()
    zz = zz.flatten()
    xx += np.mean(xlim) - np.mean(xx)
    yy += np.mean(ylim) - np.mean(yy)
    zz += np.mean(zlim) - np.mean(zz)
    return np.array((xx, yy, zz, [r] * xx.size))

# default
par = {
  "dim": 2,
  "nx": 512,
  "Lwide": 2.,
  "Lnarrow": 0.35,
  "Hwide": 1.,
  "Hnarrow": 75. / 1600.,
  "thickness": 60. / 1600.,
  "Re": 50.,
  "Ca": 0.05,
  "rho": 0.01,
  "np": 4,
  "tl": 1440,
  "bs": 32,
  "bublength": 2,
  "gapy": 0.,
  "fillbub": False,
  "fillbub_R": 0.05,
  "fillbub_regular": False,
        }

exec(open("par.py").read(), None, par)

Lwide = float(par["Lwide"])
Lnarrow = float(par["Lnarrow"])
H = float(par['Hwide'])
Hnarrow = float(par['Hnarrow'])
thickness = float(par['thickness'])
Re = par["Re"]
Ca = par["Ca"]
nx = par['nx']
fillbub = par['fillbub']
fillbub_regular = par['fillbub_regular']
fillbub_R = par['fillbub_R']
fillbub_gap = par['fillbub_gap']

extent = Lwide + Lnarrow + H * 0.5
inf = extent * 10.
lx = extent
hx = lx / nx
eps = hx * 0.01

bsx = par['bs']
bsy = bsx
bsz = bsx

ly = H + hx * 4 + par['gapy']
lz = thickness + hx * 4
assert ly <= extent
assert lz <= extent

if par['dim'] == 2:
    bsz = 1
    lz = 0

def Up(n, b):
    return max(1, n + b - 1) / b * b

ny = Up(int(nx * ly / lx + 0.5), bsy)
nz = Up(int(nx * lz / lx + 0.5), bsz)
ly = ny * hx
lz = nz * hx

# geometry
geom = aphros.Geometry()
geom.Box([lx/2, ly/2, 0], [inf, H/2, inf], invert=1)
diag = (extent - Lwide) / (2. ** 0.5)
geom.Box([0, ly/2 - H/2, 0], [inf, diag, inf], -45)
geom.Box([0, ly/2 + H/2, 0], [inf, diag, inf], 45)
geom.Box([lx/2, ly/2, 0], [inf, Hnarrow/2, inf], invert=1, intersect=1)
geom.Box([0,0,lz/2], [inf, inf, thickness/2], invert=1)


with open("body.dat", 'w') as f:
    f.write(geom.Generate())

# boundary conditions
bc = aphros.Bc()

g = aphros.Geometry()
g.Box([0, 0, 0], [inf, inf, inf])
bc.Wall(g, velocity = [0, 0, 0])

g = aphros.Geometry()
g.Box([0, 0, 0], [eps, inf, inf])
bc.Inlet(g, velocity = [1, 0, 0])

g = aphros.Geometry()
g.Box([lx, 0, 0], [eps, inf, inf])
bc.Outlet(g)

with open("bc.dat", 'w') as f:
    f.write(bc.Generate())

# volume fraction bubgen
vf = aphros.Geometry()
R = Hnarrow * par["bublength"]
vf.Box([R * 2, ly/2, lz/2], [R, Hnarrow/2, thickness/2])
with open("bg.dat", 'w') as f:
    f.write(vf.Generate())

# volume fraction
vf = aphros.Geometry()

xlim = [Lnarrow, Lnarrow + H/2 + Lwide]
ylim = [ly/2 - H/2, ly/2 + H/2]
zlim = [lz/2, lz/2]
if fillbub_regular:
    bb = GetRegularCluster(
            xlim, ylim, zlim, fillbub_R, fillbub_gap / fillbub_R)
else:
    bb = GetRandomCluster(
            xlim, ylim, zlim, fillbub_R, fillbub_gap / fillbub_R)

for i in range(len(bb[0])):
    vf.Sphere([bb[0][i],bb[1][i],bb[2][i]], [bb[3][0], bb[3][1], thickness*0.5])
with open("b.dat", 'w') as f:
    f.write(vf.Generate())

# configuration
var = aphros.Var()
for k in par:
    var[k] = par[k]

var['extent'] = float(extent)
rho = float(var['rho'])
var['mu1'] = Hnarrow / Re
var['mu2'] = var['mu1'] * rho
var['rho1'] = 1.
var['rho2'] = rho
var['sigma'] = var['mu1'] / Ca

if par['dim'] == 2:
    var['dumplist'] = "vx vy omz p"
    var['hypre_periodic_z'] = 1

with open("par.conf", 'w') as f:
    f.write(var.Generate())

np = par['np']
nb = (nx / bsx) * (ny / bsy) * (nz / bsz)
if nb % np != 0:
    np0 = np
    for np in reversed(range(1, np + 1)):
        if nb % np == 0:
            break;
    print("Warning: number of blocks nb={:} not divisible by np={:}. \
Setting np={:}.".format(nb, np0, np))
    if np <= np0 * 0.75:
        Abort("Error: np reduced by more than 25%.")

tl = par['tl']

with open("par.make", 'w') as f:
        f.write(
'''m = {nx} {ny} {nz}
bs = {bsx} {bsy} {bsz}
np = {np}
tl = {tl}
'''.format(**locals()))
