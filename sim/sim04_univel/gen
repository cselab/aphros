#!/usr/bin/env python

import argparse
import math
from ch import *

# Returns dict of {name:(value, description, choices)}
def Default():
    r = GetStdPar('Red', 'We', 'La', 'ch', 'ge', 'br',
        'dim', 'pos', 'mode', 'mu', 'rho', 'nfr', 'dom', 'rho0',
        'np', 'nx', 'cpr', 'bryk', 'vel0', 'tmax', 'bcoh', 'bcor', 'bcod',
        'b2xr', 'b2rr', 'chsm', 'gesm', 'wallx', 'wally', 'wallz', 'pois')
    r['We'][0] = 0.5
    r['Red'][0] = 10
    r['cpr'][0] = int
    r['cpr'][0] = int
    r['bcod'][0] = [0., 0.325, 0.]
    r['bcoh'][0] = [0., 0., 0.]
    r['mode'][0] = 'pois'
    r['meshvel'] = [0, "moving mesh in ch", [0, 1]]
    return r


# Returns dictionary with config derived from c.
# a: Namespace, output of GetArgs()
def GetConf(a):
    d = dict(vars(a))

    we = a.We
    la = a.La
    red = a.Red
    nx = a.nx
    np = a.np
    dom = a.dom
    cpr = a.cpr if a.cpr is not None else nx * a.br / dom
    vel0 = a.vel0 if a.dim == 3 else [a.vel0[0], a.vel0[1], 0.]
    rho0 = a.rho0
    rhom = max(a.rho0, a.rho0 * a.rho)
    tmax = a.tmax

    # mesh step
    hx = dom / nx
    # bubble radius
    brx = cpr * hx
    bry = brx * a.bryk
    brz = brx
    br = [brx, bry, brz]
    # bubble diameter
    bd = brx * 2

    if a.mode == "vel":
        # velocity magnitude brx * 2
        vm = brx * 2
        sig = vm ** 2 * bd * rho0 / we
    elif a.mode == "osc":
        # oscillation frequency: sqrt(7) / pi ~= 0.84
        sig = rho * bd ** 3
    elif a.mode == 'mu':
        mu = rho0 * bd ** 2
        sig = la * mu ** 2 / (rho0 * bd)
    elif a.mode == 'pois':
        # velocity agnitude brx
        vm = dom
        # red = bd * vm * rho / mu0
        mu = bd * vm * rho0 / red
        sig = vm ** 2 * bd * rho0 / we

    # velocity magnitude
    vm = (we * sig / (bd * rho0)) ** 0.5
    # viscosity
    if la is not None:
        mu = (sig * rhom * bd / la) ** 0.5
    # velocity
    vel = [x * vm / norm(vel0) for x in vel0]

    assert we is None or IsClose(we, rho0 * norm(vel) ** 2 * bd / sig)
    assert la is None or IsClose(la, rhom * sig * bd / mu ** 2)

    if a.mode == 'pois':
      mu0 = mu
    elif a.rho > 1.: # droplet, phase 2 heavier
        mu0 = mu / a.mu
    else: # bubble
        mu0 = mu

    # dump interval
    dumpdt = tmax / a.nfr

    r3 = range(3)
    # center of first bubble 
    bc = [br[i] + hx for i in r3] # one cell from corner

    # second bubble enabled
    b2 = bool(a.b2rr > 0)

    if a.pos == "center":
        # domain center
        dc = [a.dom * 0.5 for i in r3] 
        # center of mass of bubbles (XXX: assume same radius)
        c = [bc[i] + br[i] * a.b2xr[i] * 0.5 for i in r3] if b2 else bc
        # shift first to center
        bc = [bc[i] - c[i] + dc[i] for i in r3]

    # shift of first bubble
    bc = [bc[i] + dom * a.bcod[i] + hx * a.bcoh[i] + a.bcor[i] * br[i] for i in r3]

    # second bubble
    b2r = [br[i] * a.b2rr for i in r3]
    b2c = [bc[i] + br[i] * a.b2xr[i] for i in r3]

    pgrad = 8 * vm * mu0 / dom ** 2
    poisvel = vm

    # derived variables to return
    kk = ['sig', 'vel', 'dumpdt', 'br', 'bc', 'b2r', 'b2c', 'mu0', 
            'pgrad', 'poisvel']
    for k in kk:
        d[k] = locals()[k]

    return d

# Returns text for b.dat
# c: center, shape 3
# r: size, shape 3
def GetBub(c, r):
    return "{:} {:} {:} {:} {:} {:}".format(*(c + r))

# Returns python code defining config derived from c.
# c: Namespace, output of GetArgs()
def GetConfPy(c):
    return GetDictPy(GetConf(c))

c = Default()
a = GetArgs(c)
c = GetConf(a)
cpy = GetDictPy(c)
open("par.py", 'w').write(cpy)

with open("b.dat", 'w') as fb:
    b = GetBub(c['bc'], c['br'])
    fb.write(b + "\n")
    if c['b2r'][0] > 0.:
        b2 = GetBub(c['b2c'], c['b2r'])
        fb.write(b2 + "\n")

open("dim", 'w').write(str(c['dim']))
