#!/usr/bin/env python

import argparse
import math

# Returns dict of {name:(value, description)}
def Default():
    we = (1., "Weber number")
    la = (1000. , "Laplace number")
    np = (1     , "number of processors")
    nx = (64    , "mesh size")
    brh = (4.   , "br/h, cells per bubble radius")
    bryk = (1.2 , "stretching factor for bubble size in y")
    vel0 = ([4., 3., 2.], "direction of velocity")
    tmax = (1. , "total dimensionless time")
    bcoh = ([1.2, 1.4, 1.6], "offset of bubble center relative to h")
    bcor = ([0., 0., 0.], "offset of bubble center relative to br")
    b2xr = ([2., 0., 0.] , "second bubble displacement realative to br")
    b2rr = (0. , "second bubble radius relative to br")
    nfr = (100   , "number of frames")
    #mu0 = (0.01     , "dynamic viscosity of carrier fluid")
    mu = (1.     , "dynamic viscosity of bubble relative to carrier")
    rho0 = (1.    , "density of carrier fluid")
    rho = (1.    , "density of bubble relative to carrier")
    dom = (1.    , "domain size (ignored)")
    dim = (3    , "dimension, 2 or 3")
    chsm = (1    , "ch smooth steps (rhor>10: 1, rhor>100: 2)")
    gesm = (1    , "ge smooth steps")
    wallx = (0    , "walls in x direction, else periodic")
    wally = (0    , "walls in y direction, else periodic")
    wallz = (0    , "walls in z direction, else periodic")

    return locals().copy()

def IsClose(a, b):
    return abs(a - b) < 1e-10

# Returns Namespace with parameters from Default() overriden by args
def GetArgs():
    p = argparse.ArgumentParser(
            description='Generate conf.py and b.dat',  
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    c = Default()

    for k in c:
        v,h = c[k]
        if type(v) == list:
            m = ('X','Y','Z')
            p.add_argument('-' + k, nargs=len(v), metavar=m, 
                           default=v, help=h, type=type(v[0]))
        else:
            p.add_argument('-' + k, nargs='?',  
                           default=v, help=h, type=type(v))

    p.add_argument('-mode', default="vel", choices=["vel", "osc"], help=
'''timescale; 
vel: velocity magnitude br * 2; 
osc: oscillation frequency sqrt(7) / pi''')

    p.add_argument('-pos', default="corner", choices=["center", "corner"], 
            help= "initial position of bubbles")

    a = p.parse_args()
    return a

# Returns python code defining variables from dict c
# Returns python code defining config based on c.
# c: dict such that c.keys() includes Default().keys()
def GetDictPy(c):
    t = ""
    for k in c:
        v = c[k]
        v = '"{:}"'.format(v) if type(v) == str else str(v)
        t += "{:} = {:}\n".format(k, v)

    return t

def norm(v):
    assert len(v) == 3
    return sum([a ** 2 for a in v]) ** 0.5

# Returns dictionary with config derived from c.
# a: Namespace, output of GetArgs()
def GetConf(a):
    d = dict(vars(a))

    we = a.we
    la = a.la
    nx = a.nx
    np = a.np
    brh = a.brh
    vel0 = a.vel0 if a.dim == 3 else [a.vel0[0], a.vel0[1], 0.]
    dom = a.dom
    #mu = max(a.mu0, a.mu0 * a.mu)
    rho = max(a.rho0, a.rho0 * a.rho)
    tmax = a.tmax

    # mesh step
    hx = dom / nx
    # bubble radius
    brx = brh * hx
    bry = brx * a.bryk
    brz = brx
    br = [brx, bry, brz]
    # bubble diameter
    bd = brx * 2

    if a.mode == "vel":
        # velocity magnitude brx * 2
        vm = brx * 2
        sig = vm ** 2 * bd * rho / we
    elif a.mode == "osc":
        # oscillation frequency: sqrt(7) / pi ~= 0.84
        sig = rho * bd ** 3

    # viscosity
    mu = (sig * rho * bd / la) ** 0.5
    # velocity magnitude
    vm = (we * sig / (bd * rho)) ** 0.5
    # velocity
    vel = [x * vm / norm(vel0) for x in vel0]

    assert IsClose(we, rho * norm(vel) ** 2 * bd / sig)
    assert IsClose(la, rho * sig * bd / mu ** 2)

    if a.rho > 1.: # droplet, phase 2 heavier
        mu0 = mu / a.mu
    else: # bubble
        mu0 = mu

    # dump interval
    dumpdt = tmax / a.nfr

    r3 = range(3)
    # bubble center
    bc = [r + hx * o + oo * r for r,o,oo in zip(br,a.bcoh,a.bcor)]
    # second bubble
    b2r = [br[i] * a.b2rr for i in r3]
    b2c = [bc[i] + br[i] * a.b2xr[i] for i in r3]

    if a.pos == "center":
        dc = [a.dom * 0.5 for i in r3] # domain center
        c = [(bc[i] + b2c[i]) * 0.5 for i in r3]
        bc = [bc[i] - c[i] + dc[i] for i in r3]
        b2c = [b2c[i] - c[i] + dc[i] for i in r3]

    # derived variables to return
    kk = ['sig', 'vel', 'dumpdt', 'br', 'bc', 'b2r', 'b2c', 'mu0']
    for k in kk:
        d[k] = locals()[k]

    return d

# Returns text for b.dat
# c: center, shape 3
# r: size, shape 3
def GetBub(c, r):
    return "{:} {:} {:} {:} {:} {:}".format(*(c + r))

# Returns python code defining config derived from c.
# c: Namespace, output of GetArgs()
def GetConfPy(c):
    return GetDictPy(GetConf(c))

a = GetArgs()
c = GetConf(a)
cpy = GetDictPy(c)
open("conf.py", 'w').write(cpy)

with open("b.dat", 'w') as fb:
    b = GetBub(c['bc'], c['br'])
    fb.write(b + "\n")
    if c['b2r'][0] > 0.:
        b2 = GetBub(c['b2c'], c['b2r'])
        fb.write(b2 + "\n")

open("dim", 'w').write(str(c['dim']))
