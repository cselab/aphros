#!/usr/bin/env python

import argparse
import math
from ch import *

# Returns dict of {name:(value, description, choices)}
def Default():
    r = GetStdPar('Red', 'Reh', 'We', 'Ca', 'La', 'ch', 'ge', 'br',
        'dim', 'pos', 'mode', 'mu', 'rho', 'nfr', 'dom', 'rho0',
        'np', 'nx', 'cpr', 'bryk', 'vel0', 'tmax', 'bcoh', 'bcor', 'bcod',
        'b2xr', 'b2rr', 'chsm', 'gesm', 'wallx', 'wally', 'wallz', 'pois',
        'g0', 'Fr', 'Ga', 'Eo', 'meshvel')
    r['nb'] = [1, "number of bubbles"]
    r['symm'] = [0, "symmetry in y and z"]
    return r

# Returns pressure gradient to maintain poiseuille flow in rectangular duct
# ly,lz: size of duct
# vc: centerline velocity
# mu: viscosity
# im: depth for series evaluation
def GetPoisGrad(ly, lz, vc, mu, im=5):
    # Spiga 1994: Symmetric solution for velocity in rectangular ducts
    pi = math.pi
    b = lz / ly
    k = 16. * b ** 2 / pi ** 4

    s = 0
    y = 0.5  
    z = 0.5
    s = 0
    sin = math.sin
    for iy in range(1,im * 2,2):
        for iz in range(1,im * 2,2):
            s += sin(iy * pi * y) *  sin(iz * pi * z) / \
                (iy * iz * (b ** 2 * iy ** 2 + iz ** 2))

    p = vc / (s * k)
    pgrad = p * mu / ly ** 2
    return pgrad


# Returns dictionary with config derived from c.
# a: Namespace, output of GetArgs()
def GetConf(a):
    d = dict(vars(a))

    we = a.We
    la = a.La
    ca = a.Ca
    red = a.Red
    reh = a.Reh
    nx = a.nx
    np = a.np
    dom = a.dom
    cpr = a.cpr if a.cpr is not None else nx * a.br / dom
    vel0 = a.vel0 if a.dim == 3 else [a.vel0[0], a.vel0[1], 0.]
    rho0 = a.rho0
    rhom = max(a.rho0, a.rho0 * a.rho)
    tmax = a.tmax

    # mesh step
    hx = dom / nx
    # bubble radius
    brx = cpr * hx
    bry = brx * a.bryk
    brz = brx
    br = [brx, bry, brz]
    # bubble diameter
    bd = brx * 2

    vm = None

    if a.mode == "vel":
        # velocity magnitude brx * 2
        vm = brx * 2
        sig = vm ** 2 * bd * rho0 / we
    elif a.mode == "osc":
        # oscillation frequency: sqrt(7) / pi ~= 0.84
        sig = rhom * bd ** 3
    elif a.mode == 'mu':
        mu = rho0 * bd ** 2
        sig = la * mu ** 2 / (rho0 * bd)
    elif a.mode == 'pois':
        # velocity magnitude dom
        vm = dom
        assert (red is None) != (reh is None)
        mu = vm * rho0 * ((bd / red) if red is not None else (dom / reh))
        assert (we is None) != (ca is None)
        if we is not None:
            sig = vm ** 2 * bd * rho0 / we
        else:
            sig = vm * mu / ca

    # velocity magnitude
    if vm is None:
        vm = (we * sig / (bd * rho0)) ** 0.5 
    # viscosity
    if la is not None:
        mu = (sig * rhom * bd / la) ** 0.5
    # velocity
    vel = [x * vm / norm(vel0) for x in vel0]

    # gravity magnitude
    gm = 0.
    fr = a.Fr
    ga = a.Ga
    eo = a.Eo
    assert len([n for n in [fr, ga, eo] if n is not None]) <= 1
    assert fr is None or ga is None, 'Conflict: both Fr and Ga defined'
    if fr is not None:
        gm = vm ** 2 / (fr ** 2 * dom) 
    elif ga is not None:
        gm = ga * mu ** 2 / (bd ** 3 * rhom ** 2)
    elif eo is not None:
        gm = eo * sig / (rhom * bd ** 2)

    g0 = a.g0
    g = [x * gm / norm(g0) for x in g0]

    if a.mode == 'pois':
        mu0 = mu
    elif a.rho > 1.: # droplet, phase 2 heavier
        mu0 = mu / a.mu
    else: # bubble
        mu0 = mu

    assert we is None or IsClose(we, rho0 * norm(vel) ** 2 * bd / sig)
    assert la is None or IsClose(la, rhom * sig * bd / mu ** 2)
    assert fr is None or IsClose(fr, norm(vel) / (norm(g) * dom) ** 0.5)
    assert ga is None or IsClose(ga, norm(g) * bd ** 3 * rhom ** 2 / mu ** 2)
    assert eo is None or IsClose(eo, rhom * norm(g) * bd ** 2 / sig)
    assert red is None or IsClose(red, bd * vm * rho0 / mu0)
    assert reh is None or IsClose(reh, dom * vm * rho0 / mu0)

    # dump interval
    dumpdt = tmax / a.nfr

    r3 = range(3)
    # center of first bubble in corner
    bc = [br[i] + hx for i in r3] # one cell from corner

    # list of bubbles
    bbc = []
    bbr = []
    b2r = [br[i] * a.b2rr for i in r3]
    for k in range(a.nb):
        if not bbc:
            bbc.append(bc)
        else:
            bbc.append([bbc[-1][i] + a.b2xr[i] * br[i] for i in r3])
        bbr.append(br if len(bbr) % 2 == 0 else b2r)

    assert len(bbr) == len(bbc) and len(bbc) == a.nb


    if a.pos == "center":
        # current center of bubbles
        bc0 = [0, 0, 0]
        for k in range(a.nb):
            bc0 = [bc0[i] + bbc[k][i] for i in r3]
        bc0 = [bc0[i] / a.nb for i in r3]
        # domain center
        dc = [a.dom * 0.5 for i in r3]
        # shift to center
        for k in range(a.nb):
            bbc[k] = [bbc[k][i] + dc[i] - bc0[i] for i in r3]

    # shift of bubbles
    for k in range(len(bbc)):
        bbc[k] = [bbc[k][i] + dom * a.bcod[i] + hx * a.bcoh[i] 
                + a.bcor[i] * br[i] for i in r3]

    # pois
    poisvel = vm   # centerline velocity
    pgrad = [0., 0., 0.]
    if a.pois:
        if a.wally and a.wallz:
            pgrad = GetPoisGrad(dom, dom, vm, mu0)
        elif a.wally:
            pgrad = 8 * vm * mu0 / dom ** 2
        else:
            assert False, "pois requires wally or wallz"

    # derived variables to return
    kk = ['sig', 'vel', 'dumpdt', 'bbc', 'bbr', 'mu0', 'g', 'pgrad', 'poisvel']
    for k in kk:
        d[k] = locals()[k]

    return d

# Returns text for b.dat
# c: center, shape 3
# r: size, shape 3
def GetBub(c, r):
    return "{:} {:} {:} {:} {:} {:}".format(*(c + r))

# Returns python code defining config derived from c.
# c: Namespace, output of GetArgs()
def GetConfPy(c):
    return GetDictPy(GetConf(c))

c = Default()
a = GetArgs(c)
c = GetConf(a)
cpy = GetDictPy(c)
open("par.py", 'w').write(cpy)

with open("b.dat", 'w') as fb:
    for k in range(len(c['bbc'])):
        fb.write(GetBub(c['bbc'][k], c['bbr'][k]) + "\n")

open("dim", 'w').write(str(c['dim']))
