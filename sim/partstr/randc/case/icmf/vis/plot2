#!/usr/bin/env python

import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import glob
import os
import re
import sys
from matplotlib.colors import LinearSegmentedColormap
import scipy
import scipy.interpolate

# natural sort
def natkey(s, _nsre=re.compile('([0-9]+)')):
      return [int(text) if text.isdigit() else text.lower()
                      for text in re.split(_nsre, s)]

def natsorted(v):
  return sorted(v, key=natkey)

def Glob(d, fld):
    return natsorted(glob.glob(os.path.join(d, "{:}*.dat".format(fld))))

# Writes message to stdout
# s: string
def Log(s, noeol=False):
    if not noeol:
        s += "\n"
    sys.stdout.write(s)
    sys.stdout.flush()


# Writes message to stdout
# s: string
def Err(s, noeol=False):
    s = str(s)
    if not noeol:
        s += "\n"
    sys.stderr.write(s)


# Read uniform grid data
# p: path
# Format:
# <Nx> <Ny> <Nz>
# <u[0,0,0]> <u[0,0,1]> ...
# Return:
# array of shape (Nx, Ny, Nz) (reversed dimensions)
# None if file not found
def ReadArray(p):
    if not os.path.isfile(p):
        return None
    with open(p) as f:
        ll = f.readlines()
        # shape x,y,z
        s = np.array(ll[0].split(), dtype=int)
        # shape z,y,x
        ss = tuple(reversed(s))
        # data flat
        u = np.array(ll[1].split(), dtype=float)
        # data z,y,x
        u = u.reshape(ss)
        # data x,y,z
        u = np.transpose(u)
        if u.shape[2] == 2: # XXX: workaround for ch 2d loc=0
            u = u[:,:,:1]
        return u

# Converts field to image
def GetImg(u):
    s = u.shape
    assert len(s) in [2, 3]
    if len(s) == 3:
        u = u[:,:,0]
    return np.flipud(u.T)

def PlotInitSq():
    fig, ax = plt.subplots(figsize=(1.2,1.2))
    ax.set_aspect('equal')
    return fig, ax

def PlotInit():
    fig, ax = plt.subplots(figsize=(4,3))
    return fig, ax

def PlotInit3():
    fig = plt.figure(figsize=(4,3))
    ax = fig.gca(projection='3d')
    return fig, ax


def PlotSave(fig, ax, po):
    #fig.tight_layout()
    fig.savefig(po, dpi=300)
    plt.close()

from matplotlib.colors import LinearSegmentedColormap

# u: 2d numpy array
# po: output path
def PlotFieldGray(ax, u, vmin=None, vmax=None):
    cmap = LinearSegmentedColormap.from_list('mycmap', ['1.', '0.5'])
    ax.imshow(GetImg(u), extent=(0, 1, 0, 1), interpolation='nearest',
              vmin=vmin, vmax=vmax, cmap=cmap)

# u: 2d numpy array
# po: output path
def PlotField(ax, u, vmin=None, vmax=None):
    ax.imshow(GetImg(u), extent=(0, 1, 0, 1), interpolation='nearest',
              vmin=vmin, vmax=vmax)

# u: 2d numpy array
# po: output path
def PlotFieldBwr(ax, u, vmin=None, vmax=None):
    ax.imshow(GetImg(u), extent=(0, 1, 0, 1), interpolation='nearest',
              vmin=vmin, vmax=vmax, cmap=plt.get_cmap("bwr"))

# sx, sy: number of cells
def PlotGrid(ax, x1, y1):
    ax.set_xticks(x1)
    ax.set_yticks(y1)
    plt.setp(ax.get_xticklabels(), visible=False)
    plt.setp(ax.get_yticklabels(), visible=False)
    ax.tick_params(axis='both', which='both', length=0)
    ax.grid(True, lw=0.25, c='0.', alpha=1)

def PlotLines(ax, xa, ya, xb, yb):
    xa = xa.flatten()
    ya = ya.flatten()
    xb = xb.flatten()
    yb = yb.flatten()
    xy = np.vstack((xa, xb, ya, yb))
    xy = xy.T
    xy = xy.reshape((xa.size * 2, 2))
    ax.plot(*xy, c='k', alpha=1, lw=1.5, zorder=20)

# Fits arc to line segment.
# xa,ya: start
# xb,yb: end
# k: curvature
# x0,y0: orientation point, same side for (xc,yc) 
# Returns:
# xc,yc: circle center
# r: radius
# t1,t2: theta angles in degrees
def GetArc(xa, ya, xb, yb, k, x0, y0):
    # segment center
    xs = (xa + xb) * 0.5
    ys = (ya + yb) * 0.5
    # check that (qx,qy),(dx,dy), positively oriented
    dx = xb - xa
    dy = yb - ya
    qx = xs - x0
    qy = ys - y0
    if qx * dy - qy * dx < 0.:
        xa,xb = (xb,xa)
        ya,yb = (yb,ya)

    r = 1. / k
    dx = xb - xa
    dy = yb - ya
    # segment length
    l = (dx ** 2 + dy ** 2) ** 0.5
    # distance from centers of circle and segment
    dc = (r ** 2 - (l * 0.5) ** 2) ** 0.5
    # outer unit normal
    nx = dy / l
    ny = -dx / l
    xc = xs - nx * dc
    yc = ys - ny * dc

    t1 = np.arctan2(ya - yc, xa - xc)
    t2 = np.arctan2(yb - yc, xb - xc)
    t1 = np.degrees(t1)
    t2 = np.degrees(t2)

    return xc, yc, r, t1, t2


# ax: axes
# xa,ya: start
# xb,yb: end
# kkc: array of [x,y,k]: position of central particle and curvature
def PlotArcs(ax, xa, ya, xb, yb, kkc):
    xa = xa.flatten()
    ya = ya.flatten()
    xb = xb.flatten()
    yb = yb.flatten()

    # curvature of nearest point from kkc
    def GetCurv(x, y):
        xx = kkc[:,0]
        yy = kkc[:,1]
        kk = kkc[:,2]
        dd = ((xx - x) ** 2 + (yy - y) ** 2) ** 0.5
        k = kk[dd.argmin()]
        return k

    x0 = (xa + xb).mean() * 0.5
    y0 = (ya + yb).mean() * 0.5

    for i in range(len(xa)):
        k = GetCurv((xa[i] + xb[i]) * 0.5, (ya[i] + yb[i]) * 0.5)
        if k == 0:
            continue
        xc, yc, r, t1, t2 = GetArc(xa[i], ya[i], xb[i], yb[i], k, x0, y0)
        e = matplotlib.patches.Arc((xc, yc), 2*r, 2*r, 
                angle=0, theta1=t1, theta2=t2,
                lw=0.5, ls='-', zorder=21, edgecolor='red')
        ax.add_patch(e)

# assume 0 < nx < ny, a < 0
def GetLineEnds(nx, ny, a):
    xl = [(a + 0.5 * ny) / nx, (a + 0.5 * nx) / ny]
    xr = [(a - 0.5 * ny) / nx, (a - 0.5 * nx) / ny]

    e = []
    if -0.5 <= xl[0] and xl[0] <= 0.5:
        e.append([xl[0], -0.5])
    if -0.5 <= xr[0] and xr[0] <= 0.5:
        e.append([xr[0], 0.5])
    if len(e) < 2 and -0.5 <= xl[1] and xl[1] <= 0.5:
        e.append([-0.5, xl[1]])
    if len(e) < 2 and -0.5 <= xr[1] and xr[1] <= 0.5:
        e.append([0.5, xr[1]])

    if len(e) == 1: # if only one point found, set second to the same
        e.append(e[0])

    return e


# xc,yc: cell centers
# a: line constants
# nx, ny: unit normals
# hx, hy: cell size
# Returns:
# xa, ya, xb, yb: line end points (a,b) on cell edges
# Equation of line:
# (x-xc)/h dot n = a
def GetLines(xc, yc, a, nx, ny, hx, hy, u):
    xc = xc.flatten()
    yc = yc.flatten()
    nx = nx.flatten()
    ny = ny.flatten()
    a = a.flatten()
    u = u.flatten()

    xa = []
    ya = []
    xb = []
    yb = []
    for i in range(len(xc)):
        th = 1e-10
        if u[i] > th and u[i] < 1. - th:
            e = GetLineEnds(nx[i] * hx, ny[i] * hy, a[i])
            if len(e) == 2:
                xa.append(xc[i] + e[0][0] * hx)
                ya.append(yc[i] + e[0][1] * hy)
                xb.append(xc[i] + e[1][0] * hx)
                yb.append(yc[i] + e[1][1] * hy)

    xa = np.array(xa)
    ya = np.array(ya)
    xb = np.array(xb)
    yb = np.array(yb)

    return xa, ya, xb, yb

# ax: axi
# p: path to vtk
# kkc: array of [x,y,k]: position of central particle and curvature
def PlotVtk(ax, p, kkc):
    with open(p) as f:
        def rl():
            return f.readline()
        l = rl() # header
        l = rl() # comment
        l = rl() # ASCII
        l = rl() # DATASET
        l = rl() # POINTS N float
        m = re.findall("POINTS (\d*) float", l)[0]
        # number of points
        nv = int(m)
        if nv == 0:
            return
        vv = np.zeros((nv, 3))
        Log("vtk: reading {:} points".format(nv))
        # all points as rows
        for i in range(nv):
            l = rl()
            vv[i] = [float(a) for a in l.split()]
        pg = 4 # points per polygon
        assert nv % pg == 0
        # number of polygons
        ng = nv // pg
        # all polygons as rows
        vv = vv.reshape((ng, pg, 3))

        # select lines in plane z=0 from polygons with z>=0
        ww = []  # shape (ni,ni)
        for i in range(ng):
            vi = vv[i,:,:]
            if np.min(vi[:,2]) == 0.:
                k = 0
                kk = [0, 1, 2, 3, 0]
                for k in range(4):
                    a = vi[k]
                    b = vi[kk[k+1]]
                    if a[2] == 0 and b[2] == 0:
                        ww.append([a[:2], b[:2]])

        ww = np.array(ww)

        xa = ww[:,0,0]
        ya = ww[:,0,1]
        xb = ww[:,1,0]
        yb = ww[:,1,1]
        PlotLines(ax, xa, ya, xb, yb)
        #PlotArcs(ax, xa, ya, xb, yb, kkc)


# matploblib color cycle
def MC():
    p = plt.rcParams['axes.prop_cycle']
    return p.by_key()['color']

# Plot particle strings
# ax: axes to plot on
# p: path to csv with columns x,y,z,c (c: cell index)
# sk: plot every sk string
# Output:
# plots particles on ax with color c
# Returns:
# kk: list of (x,y,k): position of central particle and curvature
def PlotPart(ax, p, sk=1):
    d = np.loadtxt(p, skiprows=1, delimiter=',')
    if d.size == 0:
        return None
    x,y,z,c,k = (d.T)[0:5,:]
    c = c.astype(int)

    # separate strings by cell
    tt = dict()  # maps cell to lists of indices in x
    for i in range(len(c)):
        ci = c[i]
        if not ci in tt:
            tt[ci] = []
        tt[ci].append(i)

    # map cell index to [0:nc]
    nc = 16
    #c = (c * (2 ** 31 - 1) % nc).astype(float) / (nc - 1)
    cu = np.unique(c)
    np.random.seed(0)
    rnd = np.random.choice(np.arange(nc), len(cu))
    mcl = dict(zip(cu, rnd))

    cmap = plt.get_cmap("Set1")

    nh = len(tt[list(tt.keys())[0]]) // 2

    # distance between two strings
    def D(t1, t2):
        c1 = t1[nh]
        c2 = t2[nh]
        return ((x[c1] - x[c2]) ** 2 + (y[c1] - y[c2]) ** 2) ** 0.5

    # plot string tt[i] with color c
    def P(i, c):
        ti = np.array(tt[i])
        ax.plot(x[ti], y[ti], c=c, zorder=21, lw=1, alpha=1)
        ax.scatter(x[ti], y[ti], c=c, cmap=cmap, s=5, lw=0.25,
                   zorder=22, edgecolor='black')
        ih = ti[nh]
        ax.scatter(x[ih], y[ih], c='none', cmap=cmap, s=5, lw=0.9,
                   zorder=22, edgecolor='k')
    
    # indices in tt of strings already plotted
    ss = []

    # distance between string t and ss
    def DS(t):
        return min([np.inf] + [D(t, tt[i]) for i in ss])

    # index in tt of the farthest string from ss
    def FS():
        if not len(ss):
            return list(tt.keys())[0]
        ii = list(tt.keys())
        return ii[np.argmax(np.array([DS(tt[i]) for i in ii]))]

    # plot strings
    ci = 0
    cc = MC()
    for q in range(2):
        s = FS()
        if q == 1:
            P(s, cc[ci])
        ci += 1
        ss.append(s)

    # central particle and curvature
    kk = []
    for i in tt:
        ti = np.array(tt[i])
        # index of central particle
        ct = ti[len(ti) // 2]
        kk.append([x[ct], y[ct], k[ct]])
    return np.array(kk)


def IsGerris(s):
    # check if gerris (odd nx)
    return s[0] % 2 == 1

# Returns dimension by shape
def GetDim(s):
    if len(s) == 2 or s[2] in [1, 2]:
        return 2
    return 3

# s: shape of data array
# Returns:
# x1,y1,z1: coordinates of cell centers
# hx,hy,hz: mesh steps (hz=1 if 2d))
def GetGeom(s):
    [nx, ny, nz] = s
    # cells
    ge = IsGerris(s)
    sx,sy,sz = (nx,ny,nz) if not ge else (nx-1,ny-1,nz-1)
    ext = 1.  # extent
    h = ext / max(sx, sy, sz)
    hx = h
    hy = h
    hz = h
    # mesh
    if ge:
        x1 = (0. + np.arange(nx)) * hx
        y1 = (0. + np.arange(ny)) * hy
        z1 = (0. + np.arange(nz)) * hz
    else:
        x1 = (0.5 + np.arange(nx)) * hx
        y1 = (0.5 + np.arange(ny)) * hy
        z1 = (0.5 + np.arange(nz)) * hz
    return x1,y1,z1,hx,hy,hz

def GetMesh(x, y, z):
    return np.meshgrid(x, y, z, indexing='ij')

# assuming uniform mesh
def GetMeshStep(s):
    if IsGerris(s):
        return 1. / (s[0] - 1)
    return 1. / s[0]

# Returns mesh nodes
# assume [0,1]x[0,1]x[0,1] domain
def GetMeshNodes(hx, hy, hz):
    xn1 = np.arange(0., 1. + hx * 0.5, hx)
    yn1 = np.arange(0., 1. + hy * 0.5, hy)
    zn1 = np.arange(0., 1. + hz * 0.5, hz)
    return xn1, yn1, zn1

# Radius of circle form area
def GetReff2(a):
    return (a / np.pi) ** 0.5

# Radius of sphere from volume
def GetReff3(v):
    return (v / np.pi * 3. / 4.) ** (1. / 3.)

# Returns effective radius
def GetReff(vf, dim):
    x1,y1,z1,hx,hy,hz = GetGeom(vf.shape)
    # cell volume
    vc = hx * hy * hz
    # integral of vf
    v  = vf.sum() * vc
    return GetReff2(v / hz) if dim == 2 else GetReff3(v)

# Returns path template from sample path
def GetPathTemplate(p):
    d = os.path.dirname(p)
    b = os.path.basename(p)
    b = re.sub("[^\d]*", "{:}", b, count=1)
    b = os.path.splitext(b)[0] + ".{:}"
    pt = os.path.join(d, b)
    return pt

# Returns full path to field
# pt: path template, example: "ch/{:}_0.dat"
# fld: field name
def GetFieldPath(pt, fld, ext="dat"):
    if fld == "partit":
        return pt.format(fld + "_", "csv")
    return pt.format(fld + "_", ext)

# Reads field by prefix
# pt: path template
# fld: field prefix
def ReadField(pt, fld):
    p = GetFieldPath(pt, fld)
    return ReadArray(GetFieldPath(pt, fld))

# bubble location
def LoadBub():
    bb = np.loadtxt("b.dat")
    if len(bb.shape) == 2:
        return bb[0,:]
    return bb

# Figure with volume fraction
# pt: path template
# vfn: volume fraction field name
def FigVf(pt, vfn='vf'):
    vf = ReadField(pt, vfn)
    dim = GetDim(vf.shape)
    x1,y1,z1,hx,hy,hz = GetGeom(vf.shape)
    x,y,z = GetMesh(x1, y1, z1)
    ii = np.where(np.isfinite(vf))

    # bubble
    vv = LoadBub()
    cx,cy,cz,rx = vv[:4]
    ry = vv[4] if len(vv) > 4 else rx
    rz = vv[5] if len(vv) > 5 else ry

    # center of mass
    #cx = np.sum(x[ii] * vf[ii]) / np.sum(vf[ii])
    #cy = np.sum(y[ii] * vf[ii]) / np.sum(vf[ii])
    #cz = np.sum(z[ii] * vf[ii]) / np.sum(vf[ii])

    # xy slice through center of mass
    iz = np.argmin(abs(cz - z))
    if vf is not None: vf = vf[:,:,iz:iz+1]

    fig, ax = PlotInitSq()
    x1,y1,z1,hx,hy,hz = GetGeom(vf.shape)
    xn1,yn1,zn1 = GetMeshNodes(hx, hy, hz)
    x,y,z = GetMesh(x1, y1, z1)

    # grid
    PlotGrid(ax, xn1, yn1)
    # field
    PlotFieldGray(ax, vf, vmin=0., vmax=1.)
    # partilces
    pa = GetFieldPath(pt, "partit")
    # output of PlotPart
    kk = None
    if os.path.isfile(pa) and dim == 2:
        Log(pa)
        kk = PlotPart(ax, pa, sk=5)
    # interface
    pv = GetFieldPath(pt, "s", "vtk")
    if os.path.isfile(pa) and dim == 2:
        Log(pv)
        PlotVtk(ax, pv, kk)
    # closeup
    r = max(rx, ry) * 1.5
    ax.set_xlim([cx - r, cx + r])
    ax.set_ylim([cy - r, cy + r])
    # save
    po = GetFieldPath(pt, "vf", "pdf")
    Log(po)
    g = 0.01
    fig.subplots_adjust(left=-g, right=1. + g, top=1. + g, bottom=-g)
    #ax.axis('off')
    PlotSave(fig, ax, po)

# Exact trajectory.
# x0: initial center, shape (3)
# vx0: velocity, shape (3)
# tmax: total time
# n: number of segments
def GetTrajE(x0, vx0, tmax, n=150):
    x = [np.linspace(x0[d], x0[d] + vx0[d] * tmax, n) for d in range(3)]
    return x


FigVf(GetPathTemplate("vf_0000.dat"))
